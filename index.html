<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="一个生活感悟和学习之路的旅程">
<meta property="og:type" content="website">
<meta property="og:title" content="心永恒，梦已不再">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="心永恒，梦已不再">
<meta property="og:description" content="一个生活感悟和学习之路的旅程">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="心永恒，梦已不再">
<meta name="twitter:description" content="一个生活感悟和学习之路的旅程">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>心永恒，梦已不再</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">心永恒，梦已不再</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">诸葛亮出山前也没带过兵啊，你们凭啥要我有工作经验！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/面试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.tom">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="心永恒，梦已不再">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/面试/" itemprop="url">面试题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T08:21:16+08:00">
                08:21:16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>切记：不要一问一答，善于沟通。不要被动的回答问题，可以将知识延伸，聊到自己擅长的领地<br>自己的职业规划：认真想想，已3-5年为界<br>想想最后问面试官的问题                </p>
<pre><code>css面试    
</code></pre><p>一、css盒模型<br>    css中的盒子模型包括IE盒子模型和标准的W3C盒子模型。<br>border-sizing: border-box, inherit, content-box<br>标准盒子模型： 左右border+左右padding+contentwidth<br>IE盒子模型border-box: width = content+padding+border 元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制<br>inherit: 从父类继承box-sizing的值</p>
<p>二、前端一像素问题（画一条0.5px的线）</p>
<ul>
<li>transform: scaleY（0.5） 使用伪元素设置1px的边框，然后对边框进行缩放(s<br>caleY)<br>　实现思路：<br>   1、设定目标元素的参考位置<br>   2、给目标元素添加一个伪元素before或者after，并设置绝对定位<br>   3、给伪元素添加1px的边框<br>   4、用box-sizing: border-box 属性把边框都包进宽和高里面<br>   5、宽和高设置为 200%<br>   6、整个盒子模型缩小为0.5<br>   7、调整盒子模型的位置，以左上角为基准 transform-origin: 0 0;</li>
<li>border-image 设置图片的边框</li>
</ul>
<p>三、4.transition和animation的区别<br>    Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，<br>    而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。</p>
<pre><code>transition 规定动画的名字  规定完成过渡效果需要多少秒或毫秒  规定速度效果  定义过渡效果何时开始
animation  指定要绑定到选择器的关键帧的名称
</code></pre><p>四、不定宽高的DIV居中<br>    1.使用flex  在父盒子设置display: flex; justify-content: center;align-items: center<br>    2.使用css的transform      父盒子设置:display:relative<br>                Div 设置: transform: translate(-50%，-50%);position: absolute;top: 50%;left: 50%;<br>    3.display：table-cell   父盒子设置:display:table-cell; text-align:center;vertical-align:middle;<br>                Div 设置: display:inline-block;vertical-align:middle;</p>
<p>五、浮动 <a href="https://juejin.im/post/5a954add6fb9a06348538c0d" target="_blank" rel="noopener">https://juejin.im/post/5a954add6fb9a06348538c0d</a><br>    特性：浮动元素影响的不仅是自己，他会影响周围元素对其进行环绕<br>      为什么要清除浮动？（解决父元素高度坍陷问题）<br>    一个块级元素如果没有设置height,其height由子元素撑开，对子元素使用了浮动之后，子元素就会脱离文档流<br>    也就是说，父及元素中没有内容可以撑开其高度，这样父级元素height就会被忽略。这就是所谓的高度坍塌<br>      如何清除浮动<br>    1.给父级元素定义高度 2.让父级元素也浮动 3.父级定义display:table 4.父元素设置overflow:hidden<br>    clearfix:使用内容生成的方式清除浮动<br>        .clearfix:after {  // :after选择器向选定的元素之后插入内容<br>               content:””; // 生成内容为空<br>               display: block; // 块级元素显示<br>               clear:both; // 清除前面元素<br>            }<br>    不破坏文档流，没有副作用</p>
<p>七、position<br>    值：relative,static（默认值）,absolute,sticky,fixed<br>    absolute会根据上一级position的值不为static进行定位，如果向上一直没有找到position，则相对整个body进行定位<br>    fixe相对的是视图的窗口，或者frame框架（setFram的子框架，一种html标签）</p>
<p>八、css选择器分类：<br>       基本的：<br>        1.id选择器（id=”name”）<br>        2.类选择器（class=”head”）<br>        3.标签选择器（body, div, ul, li）<br>        4.全局选择器（*）<br>       复杂的：<br>        1.组合选择器（.head .head_logo）<br>        2.后代选择器 （#head .nav ul li 从父集到子孙集）<br>        3.群组选择器 (div, span, img {color:Red} 具有相同样式的标签分组显示)<br>        4.继承选择器<br>        5.伪类选择器（链接样式，a元素的伪类）<br>        6.子选择器（div&gt;p, 带大于号&gt;）<br>        7.CSS相邻相邻兄弟选择器（h1+p, 带加号+）</p>
<p>九、CSS优先级<br>    不同级别：总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性<br>        1.属性后面加!import 会覆盖页面内任何位置定义的元素样式<br>        2.作为style属性写在元素内的样式<br>        3.id选择器<br>        4.类选择器<br>        5.标签选择器<br>        6.通配符选择器（*）<br>        7.浏览器自定义或继承<br>    同一级别：后写的会覆盖先写的</p>
<p> css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素</p>
<p>十、对于行内元素，font-size指定 他们的content area的高度，由于inline box = 上下的helf-leading，如果leading为0，在这种情况下，font-size指定了inline box的高度<br>        font-size 指的是字体的高度，但是不能指定每个字形给定字体高度下的实际高度，导致了span的高度大于line-height</p>
<p>十一、z-index属性  z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。<br>            position的值的属性大于z-index   Z-index 仅能在定位元素上奏效（例如 position:absolute;）<br>            元素可拥有负的 z-index 属性值</p>
<p>十二、块元素和行内元素<br>    1.块元素会独占一行，默认情况下，其宽度自动填满父元素宽度 行元素不会占据一行，会一直排在一行，直到一行排不下<br>    2.行元素没有宽度和高度属性，块级元素即使设置了宽度，还是会独占一行<br>    块级元素： div  p forn ul li h1-h6<br>    行内元素：span img input a i</p>
<p>十三、如何画一个三角形：  设置宽高，然后用border去画<br>                 width: 0;<br>                   height: 0;<br>                   border-bottom: 100px solid cyan;<br>                   border-left: 50px solid transparent;<br>                   border-right: 50px solid transparent;</p>
<p>十四、伪类：link 表示链接正常情况下（即页面加载完成时）显示的颜色<br>        hover:表示鼠标悬停时显示的颜色<br>        visited:链接被点击时显示的位置<br>        focus：元素获得光标焦点时的颜色<br>        active: 元素处于激活状态<br>    link -&gt; visited -&gt; hover -&gt; focus -&gt; active</p>
<p>十五、雪碧图：多个图片集成在一个图片中的图<br>        使用雪碧图可以减少网络请求的次数，加快允许的速度<br>        通过background-position，去定位图片在屏幕的哪个位置</p>
<pre><code>布局面试
</code></pre><p>一、flex弹性布局，<br>    可以简单的使一个元素居中（包括水平和垂直居中）<br>栅格式系统布局，bootstrap grid</p>
<p>二、圣杯和双飞翼布局 三栏是布局（两边两栏宽度固定，中间栏宽度自适应）<br>    方案一：position（绝对定位法） center的div需要放在最后面<br>        绝对定位法原理将左右两边使用absolute定位，因为绝对定位使其脱离文档流，后面的center会自然流动到他们的上卖弄，然后margin属性，留出左右两边的宽度。就可以自适应了。<br>    方案二：float 自身浮动法 center的div需要放到后面<br>        自身浮动法的原理就是对左右使用float:left和float：right，float使左右两个元素脱离文档流，中间的正常文档流中，使用margin指定左右外边距对其进行一个定位。<br>    圣杯布局：原理就是margin负值法。使用圣杯布局首先需要在center元素外部包含一个div,包含的div需要设置float属性使其形成一个BFC，并且这个宽度和margin的负值进行匹配</p>
<p>三、左边定宽，右边自适应<br>    方案一：左边设置浮动，右边宽度设置100%  .left{float:left}  .right:{width:100%}<br>    方案二：左设置浮动，右用cacl去补宽度计算 .left{float:left} .right:{width:cacl(100vw-200px}<br>    方案三：父容器设置display：flex  right部分是设置flex：1<br>    方案四：右边div套个包裹、并前置、左及包裹 双浮动</p>
<p>四、水平居中<br>    行内元素居中（父元素text-align:center）<br>    块状元素居中（块状元素没发用text-align）<br>        1.宽度一定：margin:auto<br>        2.宽度不定：块级变行内，然后在父上text-aligin<br>                float</p>
<p>四、BFC <a href="https://juejin.im/post/5909db2fda2f60005d2093db" target="_blank" rel="noopener">https://juejin.im/post/5909db2fda2f60005d2093db</a><br>    理解：BFC是css布局的一个概念，是一块独立的渲染区域，一个环境，里面的元素不会影响到外部的元素<br>    如何生成BFC：（脱离文档流）<br>             【1】根元素，即HTML元素（最大的一个BFC）<br>             【2】float的值不为none<br>             【3】position的值为absolute或fixed<br>             【4】overflow的值不为visible（默认值。内容不会被修剪，会呈现在元素框之外）<br>             【5】display的值为inline-block、table-cell、table-caption<br>    BFC布局规则：1.内部的Box会在垂直方向，一个接一个地放置。<br>             2.属于同一个BFC的两个相邻的Box的margin会发生重叠<br>             3.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此, 文字环绕效果，设置float<br>             4.BFC的区域不会与float box重叠。<br>             5.计算BFC的高度，浮动元素也参与计算<br>    BFC作用：1.自适应两栏布局<br>         2.可以阻止元素被浮动元素覆盖<br>         3.可以包含浮动元素—清除内部浮动 原理:：触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内<br>         4.分属于不同的BFC时，可以阻止margin重叠</p>
<pre><code>js面试
</code></pre><p>一、 this的指向<br>    1.当函数作为对象的方法被调用时，this就会指向该对象。<br>    2.作为普通函数，this指向window。<br>    3.构造器调用，this指向返回的这个对象。<br>    4.箭头函数  箭头函数的this绑定看的是this所在函数定义在哪个对象下，就绑定哪个对象<br>                  如果有嵌套的情况，则this绑定到最近的一层对象上</p>
<pre><code>    this指向的固定化，并不是因为箭头函数内部有绑定this的
    机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外
    层代码块的this。正是因为它没有this，所以也就不能用作构造函数。

怎么改变this的指向呢？ 1.使用es6的箭头函数；2.在函数内部使用that = this；3.使用apply，call，bind； 4.new实例化一个对象
</code></pre><p>二、什么是闭包和原型链<br>    内部函数可以访问定义他们外部函数的参数和变量。（作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁）设计私有的方法和变量，避免全局变量的污染<br>    函数嵌套函数<br>    本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除<br>   闭包的缺陷：<br>        1.闭包的缺点就是常驻内存会增大内存使用量，并且使用不当容易造成内存泄漏<br>        2.如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。   </p>
<p>   内存溢出和内存泄漏（给的不够用| 用了不归还）<br>    内存溢出：在程序中申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出<br>    内存泄漏：在程序申请内存后，无法释放已申请的内存空间，一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重，无论多少内存，迟到会被占光</p>
<p>   举列子：闭包中的this,对象函数。匿名函数返回函数return function</p>
<p>   作用域：(由当前环境与上层环境一系列的变量对象组成！！！保证 当先执行环境里，有权访问的变量和函数是有序的，作用域链变量只能被向上访问)<br>    定义：由当前环境与上层环境的一系列变量对象组成(函数嵌套函数，内部一级级往上有序访问变量或对象)<br>    作用是：保证当前执行环境里，有权访问的变量和函数时有序的，作用域链的变量只能被向上访问<br>        变量访问到window对象及被终止，作用域链向下访问是不允许的<br>        1.改变作用域有 with try..中的catch，<br>        2.所有为定义的直接赋值的变量自动声明为全局作用域</p>
<pre><code>作用域：一套规则，管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称
    查找变量（标识符就是变量或者函数名）（只用全局作用域和局部作用域）（作用域在它创建的时候就存在了）

代码执行分为两个阶段：
    1.代码编译阶段：有编译器完成，将代码翻译可执行的代码，这个阶段会被确定
    2.代码执行阶段：有js引擎完成，主要执行可执行的大妈，这个阶段执行上下文被创建（对象被创建）

执行上下文：一个看不见得对象，存在若干个属性和变量，它被调用的时候创建的。函数被调用查看的this指向的object，object就是上下文（只有被调用的时候创建）
</code></pre><p>   作用域链: <a href="https://blog.csdn.net/yooungt13/article/details/20581635" target="_blank" rel="noopener">https://blog.csdn.net/yooungt13/article/details/20581635</a><br>        · 当代码在一个环境中执行时，会创建变量对象的一个作用域链,<br>        举例子：var name =”Tom”<br>            function sayHi () {<br>                alert(‘Hi,’+name)<br>            }<br>            sayHi()  //Hi, Tom<br>        函数sayHi()的执行环境为全局环境，所以它的变量对象为window。当函数执行到name时，先查找局部环境，找到则换回，否则顺着作用域查找，在全局环境中，<br>        找到name返回，这一查找变量的有序过程的依据就是作用域。</p>
<pre><code>· 作用域链是保证执行环境有权访问的所有变量和函数的有序访问
</code></pre><p>   原型链：函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针<em>proto</em>,<br>       该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用<em>proto</em>一直指向Object的原型对象上，而Object<br>       原型对象用Object.prototype.<em>proto</em>  = null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本防范</p>
<p>三、类的创建和继承<br>    （es5）new 一个function，在这个function的prototype里增加属性和方法, 类里面有方法和属性<br>     (es6)中class, extends<br>    继承：<br>         原型链继承： function Cat(){ } Cat.prototype = new Animal(); Cat.prototype.name = ‘cat’; 无法实现多继承<br>        构造继承：   使用父类的构造函数来增强子类实例。function Cat(name){Animal.call(this);this.name = name || ‘Tom’;} 无法继承父类原型链上的属性跟方法  installof去检验<br>        实例继承：  为父类实例添加新特性，作为子类实例的返回<br>        拷贝继承： 拷贝父类元素上的属性跟方法<br>        组合继承：构造继承 + 原型继承的组合体<br>        寄生组合继承：通过寄生方式，在构造继承上加一个Super函数(没有实例和方法) 让他的原型链指向父类的原型链<br>                  砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性<br>    如何判断是那种类型</p>
<p>四、异步回调（如何解决回调地狱）<br>    promise、generator、async/await</p>
<pre><code>promise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理
      2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱
      3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）
      4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败
        promise.all() 里面状态都改变，那就会输出，得到一个数组
        promise.race() 里面只有一个状态变为rejected或者fulfilled即输出
        promis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）
</code></pre><p>五、前端事件流<br>    事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。<br>      1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到<html>再到<body>就停止了。<br>          2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。<br>          3、冒泡阶段：事件又传播回文档<br>       阻止冒泡事件event.stopPropagation()<br>           function stopBubble(e) {<br>                if (e &amp;&amp; e.stopPropagation) { // 如果提供了事件对象event 这说明不是IE浏览器<br>                  e.stopPropagation()<br>                } else {<br>                  window.event.cancelBubble = true //IE方式阻止冒泡<br>                  }<br>                 }<br>       阻止默认行为event.preventDefault()<br>     function stopDefault(e) {<br>        if (e &amp;&amp; e.preventDefault) {<br>          e.preventDefault()<br>        } else {<br>          // IE浏览器阻止函数器默认动作的行为</body></html></p>
<pre><code>    window.event.returnValue = false
  }
}
</code></pre><p>事件如何先捕获后冒泡？<br>  在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，<br>    对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p>
<p>哪些事件不支持冒泡事件：鼠标事件：mouserleave  mouseenter<br>            焦点事件：blur focus<br>            UI事件：scroll resize</p>
<p>六、事件委托（提高性能）<br>    简介：事件委托指的是，不在事件的（直接dom）上设置监听函数，而是在其父元素上设置监听函数。通过事件冒泡，父元素可以监听到子元素上事件的触发<br>          通过判断事件发生元素DOM的类型，来做出不同的响应。<br>    举例子： 最经典的就是ui和li标签的事件监听，比如我们在添加事件的时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加<br>    好处：可以比较合适动态元素的绑定，新添加的子元素也会监听函数，也可以有事件触发机制</p>
<p>七、js的new操作符做了什么？<br>    new操作符创建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象（return this）。<br>    如果不要父类的属性跟方法，在函数的prototype上去new这个父类。</p>
<p>八、改变函数内部this指针的指向函数(bind,apply,call)<br>    通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2…这种形式。</p>
<pre><code>bind 一个是返回一个函数，并不会立即执行 第二个是带参数（第一个参数要指向的this，后面的的参数用来传递
</code></pre><p>九、深拷贝和浅拷贝 <a href="https://juejin.im/post/5b00e85af265da0b7d0ba63f" target="_blank" rel="noopener">https://juejin.im/post/5b00e85af265da0b7d0ba63f</a> 从堆和栈都是内存中划分出来用来存储的区域开始讲起<br>    基本类型：undefined,null,Boolean,String,Number,Symbol 在内存中占据固定大小，保存在栈内存中<br>    引用类型：Object,Array,Date,Function,RegExp等    引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。<br>     基本类型的复制: 其实就是创建了一个新的副本给将这个值赋值给新变量， 改变值旧对象不会改变<br>     引用类型的复制： 其实就是复制了指针，这个最终都将指向同一个对象，改变其值新对象也会改变<br>    基本类型的比较 == 会进行类型转换</p>
<pre><code>浅拷贝：仅仅就是复制了引用，彼此操作不影响，slice() concat()  object.assign
深拷贝：在堆中重新分配内存，不同的地址，相同的值,互不影响的 JSON.parse()将一个js对象序列化为一个json字符串  JSON.stringify()将json字符串反序列化为一个js对象  es6的展开 {...}
深拷贝和浅拷贝的主要区别是：在内存中的存储类型不同
    浅拷贝：重新在堆栈中创建内存，拷贝前后对象的基本类型互不影响。只拷贝一层，不能对对象进行子对象进行拷贝
    深拷贝：对对象中的子对象进行递归拷贝，拷贝前后两个对象互不影响
</code></pre><p>十、跨域<br>    同源策略（协议+端口号+域名要相同）<br>    1、jsonp跨域(只能解决get）<br>        原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容<br>        步骤：1.去创建一个script标签<br>              2.script的src属性设置接口地址<br>              3.接口参数，必须要带一个自定义函数名，要不然后台无法返回数据<br>              4.通过定义函数名去接受返回的数据        </p>
<pre><code>2、document.domain 基础域名相同 子域名不同
    3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name
    4、服务器设置对CORS的支持
    原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求
   5、利用h5新特性window.postMessage()

iframe元素创建包含另外一个文档的内联框架（行内框架）(setTimeout进行异步加载)
  解释：浏览器中的浏览器！用于设置文本或者图形的浮动图文框或容器
  它和跨域
    1、document.domain 实现主域名相同，子域名不同的网页通信
      都设置为超域：document.domain = &apos;demo.com&apos;
    2、window.postMessageht(data, url)，h5的API，启动跨域通信
</code></pre><p>十一、图片的懒加载和预加载<br>    预加载：提前加载图片，当用户需要查看是可以直接从本地缓存中渲染<br>      为什么要使用预加载：在网页加载之前，对一些主要内容进行加载，以提供用户更好的体验，减少等待时间。<br>                  否则，如果一个页面的内容过于庞大，会出现留白。<br>        解决页面留白的方案：1.预加载  2.使用svg站位图片，将一些结构快速搭建起来，等待请求的数据来了之后，替换当前的占位符<br>    实现预加载的方法：<br>             1.使用html标签<br>            2.使用Image对象<br>            3.使用XMLHTTPRequest对像，但会精细控制预加载过程</p>
<pre><code>懒加载（lazyload）：客户端优化，减少请求数和延迟请求数
    提升用户体验，
    减少无效资源的加载
    防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用
  原理：首先将页面上的图片的src属性设置为空字符串，而图片的真是路经则设置带data-original属性中，
    当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入到可视区域
    ，如果图片在可视区域将图片的src属性设置为data-original的值，这样就可以实现延迟加载。    
</code></pre><p>十二、函数节流防抖<br>    什么是防抖：短时间内多次触发同一个事件，只执行最后一次，或者在开始时执行，中间不执行。比如公交车上车，要等待最后一个乘客上车<br>        什么是节流：节流是连续触发事件的过程中以一定时间间隔执行函数。节流会稀释你的执行频率，比如每间隔1秒钟，只会执行一次函数，无论这1秒钟内触发了多少次事件<br>    都为解决高频事件而来， scroll mousewhell mousemover touchmove onresize</p>
<p>十三、将arguments类数组转化为数组的方法<br>    Array.apply(null, arguments)<br>    Array.prototype.slice.apply(arguments)<br>    Array.from(arguments)</p>
<p>十四、高阶函数<br>    一、函数作为参数传递 抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中。这样一来可以分离业务代码中变化与不变的部分<br>        回调函数<br>    二、函数作为返回值传递</p>
<p>十五、如何判断一个变量是对象还是数组（prototype.toString.call()）。<br>    千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。<br>    typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。<br>        对于引用类型：除function，都返回object   null返回object。<br>    installOf() 用来判断A是否是B的实例，installof检查的是原型。<br>    toString() 是Object的原型方法，对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p>
<pre><code>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。

isProperty()方法测试一个对象是否存在另一个对象的原型链上。
</code></pre><p>十六、setTimeout 和 setInterval的机制<br>    因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的<br>    待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码</p>
<p>十七、var let const<br>    const：定义的变量不可修改，必须初始化 ，<br>    var：定义的变量可以修改，如果不初始化输出undefined，不会报错<br>    let：块级作用域，函数内部使用let定义后，会函数外部无影响<br>    let const 不会造成变量的提升</p>
<p>十八、js垃圾回收机制<br>    1.JS具有自动垃圾收集的机制<br>    2.JS的内存生命周期（变量的生命）<br>        1.分配你所需要的空间 var a = 20<br>        2.使用分配带的内存（读写） alert（a + 10）<br>        3.不适用的时候，释放内存空间 a = null<br>    3.JS的垃圾收集器每隔固定的时间就执行一次释放操作，通用的是通过标记清除的算法<br>    4.在局部作用域中，垃圾回收器很容易做出判断并回收，全局比较难，因此应避免全局变量</p>
<pre><code>标记清除算法：js最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将他标记为&apos;进入环境&apos;，
      当变量离开（函数执行完后），就其标记为&apos;离开环境&apos;。垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，
      然后去掉环境中的变量以及被环境中该变量所引用的变量（闭包）。在这些完成之后仍存在标记的就是要删除的变量了
</code></pre><p>十九、渐进增强和优雅降级<br>    1.渐进增强就是针对低版本浏览器进行构建页面，保证最基本的功能，然后对高级浏览器进行效果、交互等改进和最佳功能达到更好的用户体验<br>    2.优雅降级：一开始构建完整的功能，然后对低版本的进行兼容</p>
<p>二十、undefined 和 null<br>    1.undefined类型只要一个，即undefined，当声明变量还未被初始化时就是undefined<br>    2.null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象<br>    3.NaN 与任何值都是相比较的结果都是false</p>
<p>二十一、valueof和tostring<br>    valueof：所有对象都有valueof，如果存在任意原始值，他就默认将对象转化为表示它的原始值。<br>                      如果对象是复合值，而却大部分对象无法真正表示一个原始值，因此默认的valueof()方法简单的返回对象本身，而不是返回原始值。<br>                      数组、函数和正则表达式简单的继承了这个more方法，返回对象本身</p>
<p>二十二、输入框的change和input事件<br>    onchange事件：要在input失去焦点的时候才触发<br>    oninput事件：要在用户输入的时触发，他是元素值发生变化时立即触发</p>
<p>二十三、同步和异步<br>    同步：由于js单线程，同步任务都在主线程上排队执行，前面任务没有执行完成，后面的任务会一直等待<br>    异步：不进入主线程，进入任务队列，等待主线程任务执行完成，开始执行。最基本的异步操作SetTimemot和SetInterval,等待主线程任务执行完，在开始执行里面的函数</p>
<p>二十四、函数的柯里化<br>     概念：一个函数接受函数A作为参数，运行后返回return function一个新的函数，并且可以处理A中的参数（只接受单一参数的函数）<br>     意义：将函数完全变成了接受一个参数，返回一个参数的固定形式，便于讨论和优化</p>
<p>二十五、while<br>    while循环会在指定条件为真时循环执行代码</p>
<p>二十六、TypeScript的优点：<br>      1、编译时的强类型，变成了强类型语言，还是编译成js 编译的时候就可以检验<br>      2、更好的模块化<br>      3、更好的是实现面向对象的编程，类、接口、模块</p>
<p>二十七、js的阻塞特性：所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。<br>              直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。<br>              为了提高用户体验，新一代浏览器都支持并行下载JS，但是JS下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。<br>    css阻塞：因为浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。<br>         而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。</p>
<p>二十八、meta元素可提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词</p>
<pre><code>node面试
</code></pre><p>一、koa中间件执行机制<br>    1.添加中间件的方式是使用Koa实例的use方法，并传入一个generator函数，这个generator函数接受一个next参数<br>    2.use的原理：function Application () {this.middleware = [] // 这个数组就是用来装一个个中间间的}<br>    3.每次执行use方法，就把外面传进来的generator函数push到middleware数组中<br>        app.use = function (fn) {this.middleware.push(fn)}<br>    4.koa中是预先通过use方法，将请求可能会经过的中间间装在一个数组中。<br>    5.callback函数就是请求到来的时候执行的回调。把装着中间件middleware的数组作为参数传递为compose这个方法。<br>    6.componse把毫无关系的一个个中间件给收尾串起来了，就好比我们平常的烤面筋<br>    7.componse将中间件从最后一个开始处理，并一直往前知道第一个中间件。其实最关键的就是将最后一个中间件得到generator<br>       作为参数传递给前一个中间件。当最后一个中间件的参数next是空的generator函数生成对象</p>
<pre><code>中间件是怎么跑起来的：https://juejin.im/post/591c8b4544d904006c90a2cb




                            vue面试
</code></pre><p>一、介绍下MVVM(数据的双向绑定）<br>    M: model数据模型<br>    V: view 界面<br>    MV:作为桥梁负责沟通view跟model<br>     只关心数据的流传，减少强耦合性。最关键的就是数据的双向绑定<br> 关键步骤：1.实现数据监听器Observer，用object.defineProperty()重写数据的get/set。值更新就在set中通知订阅者更新数据<br>      2.实现模板编译compile，深度遍历dom树，对每个元素节点的指令模板替换数据以及订阅数据<br>      3.实现watch用于连接Observer和compile，能够订阅并接受每一个属性的变动的通知，执行指令绑定的相应的回调函数，从而更新数据</p>
<p>mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，<br>加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到View 。</p>
<p>二、 eventBus vuex<br>     原理：eventbus 解决了兄弟组件之间事件传递问题,本质是订阅发布者模式，从而摆脱了兄弟之间需要父组件转而传递的复杂。还有一种方法是vuex数据流，单一状态树,rootState树根<br>              名词，专车。订阅者跟发布者都引用专车，这个vue实例，来完成订阅发布者。 emit（发布）  on(订阅一个组件)<br> npm包    vue-event-proxy</p>
<pre><code>vuex 是将数据单独的抽离出来，一种状态管理工具，它借鉴的是Flux、redux的基本思想，将转态抽离到全局形成一个store
</code></pre><p>三、watch:<br>    对属性进行监听，允许我们执行异步操作，限制我们执行该操作的频率（debounce），并在我们得到结果前，设置中间转态。</p>
<p>四、Vue的双向数据绑定实现原理<br>    1.核心就是数据劫持 + 发布/订阅者模式：vue使用的是Object.defineProperty()通过监听他的get/set事件，监听对数据的操作，从而触发数据同步</p>
<p> Object.defineProperty缺陷的：<br>    1.只能对属性进行数据劫持，并且需要深度遍历整个对象<br>    2.对于数组不能监听数据的变化<br>    而proxy原生支持监听数组的变化，并且可以直接对整个对象进行拦截，所有Vue在下个版本中用proxy替换object.defineProperty</p>
<p>五、nextTick原理</p>
<p>六、生命周期函数  <a href="https://juejin.im/post/5b41bdef6fb9a04fe63765f1" target="_blank" rel="noopener">https://juejin.im/post/5b41bdef6fb9a04fe63765f1</a><br>        new Vue（创建一个Vue对象）–&gt; beforeCreate –&gt; observer Data(开始监控data对象数据变化） –&gt; init event(vue内部初始化事件）</p>
<pre><code>     --&gt; created()  --&gt; compile(编译模板,把data里面的数据和模板生成html)  --&gt;  beforeMount(还没有生成HTML到元素上)  --&gt;

     mounted(挂载完成，也就是模板中的html渲染到了html页面中）  --&gt;  beforeUpdate (Vritual Dom)  --&gt; updated  --&gt; beforeDestroy --&gt; destroyed    

1.ajax请求最好放在created里面，页面可以访问到this了
2.关于dom的操作要放在mounted里面，在mounted前面还没有生成dom
3.每次进入/离开组件都要做一些事情，用什么钩子函数：
    不缓存：进入的时候可以用created和mounted钩子，离开的时候可以使用beforedDestory（可以访问this）和destoryed


    缓存：缓存了组件之后，在次进入组件不会触发beforeCreate，created, beforeMount,mounted
          如果你想每次进入组件都做一些事情的话，你可以放在activated进入缓存组件的钩子中
</code></pre><p>七、keep-alive<br>    在被keep-alive包含的组件/路由，会多出两个生命周期：activated 和 deactivated<br>    actived在组件第一次渲染时会被调用，之后再每次缓存组件被激活时调用 调用机制：第一次进入缓存路由/组件，在mounted后面，beforeRouteEnter守卫传给 next 的回调函数之前调用：</p>
<p>八、Vue的SPA 如何优化加载速度<br>    1.减少入口文件体积<br>    2.静态资源本地缓存<br>    3.开启Gzip压缩<br>    4.使用SSR,nuxt.js</p>
<p>九、模块化<br>    基本概念： 1.在js中，一个模块就是实现特定功能的文件(js文件)<br>           2.遵循模块的机制，想要什么就加载什么模块<br>           3.模块化开发需要遵循规范</p>
<pre><code>js实现模块化规范
        1.AMD 浏览器  requirejs  模块被异步加载，模块加载不影响后面语句的运行 默认使用baseURL+ paths的路经解析方式
        2.CommonJS  nodejs  
        3.ES6的import/export
        4.CMD 浏览器端 

解决的问题：1.命名冲突 2.文件依赖 3.模块的复用 4.统一规范和开发方式
</code></pre><p>十、谈谈Vue和React组件化的思想<br>    1.我们在各个页面开发的时候，会产生很多重复的功能，比如element中的xxxx。像这种纯粹非页面的UI，便成为我们常用的UI组件，最初的前端组件也就仅仅指的是UI组件<br>    2.随着业务逻辑变得越来多是，我们就想要我们的组件可以处理很多事，这就是我们常说的组件化，这个组件就不是UI组件了，而是包具体业务的业务组件<br>    3.这种开发思想就是分而治之。最大程度的降低开发难度和维护成本的效果。并且可以多人协作，每个人写不同的组件，最后像撘积木一样的把它构成一个页面    </p>
<p>十一、vue的依赖收集和watch原理</p>
<pre><code>React
</code></pre><p>一、react和vue的区别<br>       =&gt;  相同点：<br>        1.数据驱动页面，提供响应式的试图组件<br>        2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范<br>        3.数据流动单向，都支持服务器的渲染SSR<br>        4.都有支持native的方法，react有React native， vue有wexx<br>    =&gt;  不同点：<br>        1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的<br>        2.数据渲染：大规模的数据渲染，react更快<br>        3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目<br>        4.开发风格：react推荐做法jsx + inline style把html和css都写在js了<br>                vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件</p>
<p>二、redux中的reducer（纯函数）<br>    Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）更新state(这个state可以理解为上下累加器的结果）<br>    每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是’自身消减’(reduce),进而返回最新的state,这也就是典型reduce函数的用法：state -&gt;  action -&gt;  state</p>
<p>三、react的refs<br>    refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，<br>    它将接受地城dom元素或组件的已挂在实例，作为第一个参数</p>
<p>四、react中的keys<br>    帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它</p>
<p>五、React的生命周期<br>    三个状态：Mounting(已插入真实的DOM）<br>          Updating(正在被重新渲染)<br>          Unmounting(已移除真实的DOM)<br>    componentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，<br>    componentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用</p>
<p>六、React子组件向父组件传值<br>    父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。</p>
<p>七、React数据流</p>
<p>八、为什么虚拟DOM会提高性能 <a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/29504639?sort=created</a><br>    虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能<br>    具体实现步骤：<br>        ·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中<br>            ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异<br>        ·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。</p>
<p>九、diff算法<br>    1.把树形结构按照层级分解，只比较同级元素<br>    2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记<br>    3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面<br>    Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用<br>    react只会匹配相同的class的component（这里的class指的是组件的名字）<br>    合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制<br>    4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能    </p>
<p>十、super</p>
<p>十一、简述下flux的思想<br>    flux的最大特点，就是数据的‘单向流动’<br>    1.用户访问View<br>    2.View发出用户的Action<br>    3.Dispatcher收到Action,要求state进行相应的更新<br>    4.store更新后，发出一个‘change’事件后，更新页面</p>
<p>十二、reac性能优化是哪个周期函<br>    shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，<br>    如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能</p>
<p>十三、react怎么划分业务组件和技术组件<br>    根据组件的职责通常把组件分为UI组件和容器组件<br>    UI组件负责UI的呈现，容器组件负责管理数据和逻辑<br>    两者通过React-redux提供connect方法联系起来</p>
<p>十四、setState<br>    setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列<br>    而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值<br>    那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误</p>
<pre><code>同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state

同步更新state:
    setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行
    也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步

例子：componentDidMount() {

    fetch(&apos;https://test.com&apos;)

    .then((res) =&gt; res.json())

    .then(
</code></pre><p>(data) =&gt; {<br>this.setState({ data:data });</p>
<pre><code>    StatusBar.setNetworkActivityIndicatorVisible(false);
}


            性能优化
</code></pre><p>一、webpack打包文件体积过大？（最终打包为一个js文件）<br>    1.异步加载模块<br>    2.提取第三库<br>    3.代码压缩<br>    4.去除不必要的插件</p>
<p>如何优化webpack构建的性能<br>    一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积<br>             2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理<br>             3.对一些组件库采用按需加载，避免无用的代码<br>    二、减少目录检索范围<br>             ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度</p>
<pre><code>三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias
</code></pre><p>二、我们把开发中的所有资源（图片，js、css文件）都看成模块，通过loader和plugins来对资源进行处理，打包成符合生产环节部署的前端资源。</p>
<p>三、移动端的性能优化<br>      1、首屏加载和按需加载，懒加载<br>      2、资源预加载<br>      3、图片压缩处理，使用base64内嵌图片<br>      4、合理缓存dom对象<br>      5、使用touchstart代替click（click 300毫秒的延迟）<br>      6、利用transform:translateZ(0)，开启硬件GUP加速<br>      7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明<br>      8、使用viewport固定屏幕渲染，加速页面渲染内容<br>      9、尽量使用事件代理，避免直接事件绑定</p>
<p>四、Vue的SPA 如何优化加载速度<br>    1.减少入口文件体积<br>    2.静态资源本地缓存<br>    3.开启Gzip压缩<br>    4.使用SSR,nuxt.js</p>
<p>五、移动端300ms延迟<br>    由来：300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。<br>         由于用户可以双击缩放或者是滚动的操作，当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作<br>        因次，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕<br>    解决方案：1.禁用缩放，设置meta标签 user-scalable=no<br>          2.fastclick.js<br>            原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即<br>                  发出click事件，并把浏览器在300ms之后真正的click事件阻止掉<br>    fastclick.js还可以解决穿透问题</p>
<p>六、页面的重构；在不改变外部行为的前提下，简化结构、添加可读性</p>
<pre><code>服务器端
</code></pre><p>一、状态码：</p>
<pre><code>2XX（成功处理了请求状态）
    200 服务器已经成功处理请求，并提供了请求的网页
    201 用户新建或修改数据成功
    202 一个请求已经进入后台
    204 用户删除成功
3XX（每次请求使用的重定向不要超过5次）
    304 网页上次请求没有更新，节省带宽和开销
4XX（表示请求可能出错，妨碍了服务器的处理）
    400 服务器不理解请求的语法
    401 用户没有权限（用户名，密码输入错误）
    403 用户得到授权（401相反），但是访问被禁止
    404 服务器找不到请求的网页，
5XX（表示服务器在处理请求的时候发生内部错误）
    500 服务器遇到错误，无法完成请求
    503 服务器目前无法使用（超载或停机维护）
</code></pre><p>二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销<br>    1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）<br>    2.304是    HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件<br>    3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tage客服端渲染该页面，并把Tage也存储在缓存中。客户端再次请求页面A<br>        并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回304</p>
<pre><code>last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间
        客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，
        询问该事件之后文件是否被修改，没修改返回304

 有了Last-Modified，为什么还要用ETag？
  1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）
  2、某些服务器不能精确的得到文件的最后修改时间
  3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get

ETag，为什么还要用Last-Modified？
  1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
  2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。


ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
  1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
</code></pre><p>三、get/post的区别<br>    1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&amp;相连； post方法是把提交的数据放在http包的Body中<br>    2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制<br>    3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值<br>    4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上</p>
<p>四、http协议的理解<br>    1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议<br>    2.基于TCP/IP通信协议来传递数据（HTML，图片资源）<br>    3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统<br>    4.http请求信息request：<br>        请求行（request line）、请求头部（header）,空行和请求数据四部分构成</p>
<pre><code>    请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
    请求头部，用来说明服务器要使用的附加信息
    空行，请求头部后面的空行是必须的
    请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
    状态行、消息报头、空行和响应正文

    状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
    消息报头，用来说明客户端要使用的一些附加信息
    空行，消息报头后面的空行是必须的
    响应正文，服务器返回给客户端的文本信息。
</code></pre><p>五、http和https<br>    https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密<br>    http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少</p>
<p>五、http1.0 1.1 2.0的区别<br>    长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接<br>    节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）<br>    host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域</p>
<pre><code>1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源
</code></pre><p>六、koa和express的区别<br>    1.异步流程的控制。express采用callback来处理异步，koa2采用的是async/await<br>    2.错误处理。express采用callback捕获异常，对深层次的异常捕获不了。koa采用try/catch</p>
<p>七、web缓存<br>    1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本<br>    2.缓存的好处<br>            （1）减少不必要的请求<br>        （2）降低服务器的压力，减少服务器的消耗<br>        （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）</p>
<p>八、常见的web安全及防护原理<br>    1.sql注入原理：通郭sql命令插入到web表单递交或者输入活命，达到欺骗服务器执行的恶意sql命令<br>            防范：1.对用户输入进行校验<br>                   2.不适用动态拼接sql<br>    2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。<br>                    举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息<br>                防范：1.尽量采用post而不使用get提交表单<br>                      2.避免cookie中泄漏用户的隐式<br>    3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求<br>                举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据<br>                防范：在客服端页面增加伪随机数，通过验证码<br>    XSS和CSRF的区别：<br>       1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包<br>       2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包</p>
<p>九、CDN（内容分发网络）<br>    1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。<br>    2.关键技术：内容存储和分发技术中<br>    3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术<br>            将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）</p>
<p>十、TCP三次握手    (客服端和服务器端都需要确认各自可收发）<br>    客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。<br>    第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段<br>    第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段<br>    第三次握手： 服务器端确认客服端收到了自己发送的报文段</p>
<p>十一、从输入url到获取页面的完整过程  <a href="https://blog.csdn.net/samjustin1/article/details/52650520" target="_blank" rel="noopener">https://blog.csdn.net/samjustin1/article/details/52650520</a><br>    1.查询NDS(域名解析),获取域名对应的IP地址<br>        查询浏览器缓存<br>    2.浏览器与服务器建立tcp链接（三次握手）<br>    3.浏览器向服务器发送http请求(请求和传输数据）<br>    4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器<br>    5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤<br>    6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来</p>
<p>十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print<br>    流程：解析html以及构建dom树 -&gt; 构建render树 -&gt;  布局render树 -&gt; 绘制render树<br>    概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树<br>          2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）<br>          3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置<br>          4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点</p>
<pre><code>重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上
    触发重绘的条件：改变元素外观属性。如：color，background-color等
    重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观
注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局

重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。
    每个页面都需要一次回流，就是页面第一次渲染的时候

重排一定会影响重绘，但是重绘不一定会影响重排
</code></pre><p>十三、为什么css放在顶部而js写在后面<br>    1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了<br>    2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。<br>    3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验</p>
<pre><code>但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面



                    设计模式
</code></pre><p>一、观察者模式：<a href="https://juejin.im/post/5a14e9edf265da4312808d86" target="_blank" rel="noopener">https://juejin.im/post/5a14e9edf265da4312808d86</a>   <a href="https://juejin.im/post/5af05d406fb9a07a9e4d2799" target="_blank" rel="noopener">https://juejin.im/post/5af05d406fb9a07a9e4d2799</a><br>    在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系<br>    简单理解：数据发生改变时，对应的处理函数就会自动执行。一个Subjet,用来维护Observers,为某些event来通知（notify）观察者</p>
<p>二、发布-订阅者  有一个信息中介，过滤 耦合性低<br>    它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。</p>
<p>两者的区别：<br>    1.观察者模式中，观察者知道Subject ,两者是相关联的，而发发布订阅者只有通过信息代理进行通信<br>    2.在发布订阅模式中，组件式松散耦合的。正好和观察者模式相反。<br>    3.观察者大部分是同步的，比如事件的触发。Subject就会调用观察者的方法。而发布订阅者大多数是异步的（）<br>    4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。</p>
<p>1004001111<br>                             数据结构和算法</p>
<p>一、两个栈实现一个队列，两个队列实现一个栈 <a href="https://www.cnblogs.com/MrListening/p/5697459.html" target="_blank" rel="noopener">https://www.cnblogs.com/MrListening/p/5697459.html</a></p>
<p>二、红黑树（解决二叉树依次插入多个节点时的线型排列） <a href="https://juejin.im/post/5a27c6946fb9a04509096248" target="_blank" rel="noopener">https://juejin.im/post/5a27c6946fb9a04509096248</a></p>
<p>三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）<a href="https://juejin.im/post/5a2ff8c651882533d0230a85" target="_blank" rel="noopener">https://juejin.im/post/5a2ff8c651882533d0230a85</a></p>
<p>四、十大排序<br>    1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。<br>      实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个<br>            2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数<br>            3.针对所有的元素重复以上的步骤，除了最后一个<br>            4.重复步骤1-3，直到排序完成。<br>    2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾<br>      实现过程：</p>
<pre><code>3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入
  实现过程：1.从第一个元素开始，该元素可以认为已经被排序
        2.取出下一个元素，在已排序的元素序列中冲后向前扫描
        3.如果该元素（以排序）大于新元素，将元素向后移一位

4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序

1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现
  实现过程：1.从数组中挑出一个元素，成为一个基准
        2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）
        这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。
        3.递归的把小于基准值的子数列和大于基准值元素的子数列排序
算法实现： function quickSort (arr) {
        if （arr.length &lt;= 1） {return arr}
        var destIndex = Math.floor(arr.length/2)
        var left = [], right = [];
        var dest = arr.splice(destIndex,1)[0];
        for (var i =0;i&lt;arr.length;i++){
            if (arr[i]&lt;dest) {
            left.push(arr[i])
            } else {
            right.push(arr[i]) }
        return quickSort(left).concat([dest],quickSort(right)


2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。
  实现过程：1.
</code></pre><p>五、数组去重 <a href="https://juejin.im/post/5aed6110518825671b026bed#heading-6" target="_blank" rel="noopener">https://juejin.im/post/5aed6110518825671b026bed#heading-6</a><br>    1.双重循环<br>    2.indexOf<br>    3.数组排序去重 最快你Olong</p>
<p>六、字符串<br>    判断回文字符串：（递归的思想）<br>        1.字符串分隔，倒转，聚合[…obj].reverse().join(‘’)<br>        2.字符串头部和尾部，逐次向中间检测<br>            实现：function isPalindrome(line) {<br>                line += ‘’;<br>                for (var i=0,j=line.length-1;i&lt;j;i++,j–) {<br>                    if (line.chartAt(i) !== line.chartAt(j) {<br>                    return false<br>                }</p>
<pre><code>3.递归
</code></pre><p>七、二分查找（有序数组的查找）<br>     // 二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数<br>    //  (1) 一开始,数据范围覆盖整个数组。<br>    //  (2) 将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。<br>    //  (3) 就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T<br>    代码实现：function binarySearch (data, dest, start, end){<br>            var end = end || data.length-1;<br>            var start = start || 0;<br>            var m = Math.floor((start+end)/2);<br>            if (dest&lt;data[m]){<br>                return binarySearch(data, dest,0, m-1)<br>            } else {<br>                return binarySearch(data, dest, m+1, end)<br>            }}<br>            return false</p>
<pre><code>手写代码
</code></pre><p>一、动手实现一个bind（原理通过apply，call）<br>    一句话概括：1.bind()返回一个新函数，并不会立即执行。<br>            2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数<br>            3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效<br>Function.prototype.bind = function (obj, arg) {<br>   var arg = Array.prototype.slice.call(arguments, 1);<br>   var context = this;<br>   var bound = function (newArg) {<br>   arg = arg.concat(Array.prototype.slice.call(newArg);<br>   return context.apply(obj, arg)<br>}<br>  var F =  function () {}  // 在new一个bind会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程<br>  F.prototype = context.prototype;00…………………..<br>  bound.prototype =  new F();<br>  return bound;<br>}    </p>
<p>二、 AJAX （异步的javascript和xml）<br>    ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。<br>    优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载<br>          可以把前端服务器的任务转嫁到客服端来处理，减轻服务器负担，节省宽带<br>    劣势：不支持back。对搜索引擎的支持比较弱；不容易调试<br>    怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，<br>    解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax<br>function getData(url) {<br>    var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象<br>    xhr.open(‘get’, url, true)  // 设置一个http请求，设置请求的方式，url以及验证身份<br>    xhr.send() //发送一个http请求<br>    xhr.onreadystatechange = function () {  //设置一个http请求状态的函数<br>      if (xhr.readyState == 4 &amp;&amp; xhr.status ==200) {<br>        console.log(xhr.responseText)  // 获取异步调用返回的数据<br>      }<br>    }<br>  }<br>  Promise(getData(url)).resolve(data =&gt; data)</p>
<pre><code>AJAX状态码：0 - （未初始化）还没有调用send()方法
        1 - （载入）已调用send方法，正在发送请求
        2 - （载入完成呢）send()方法执行完成
        3 - （交互）正在解析相应内容
        4 - （完成）响应内容解析完成，可以在客户端调用了
</code></pre><p>三、函数节流（throttle）<br> function throttle (func, wait) {<br>        var timeout;<br>        var previous = 0;<br>        return function () {<br>            context = this;<br>            args = arguments;<br>            if (!timeout) {<br>                timeout = setTimeout(() =&gt; {<br>                    timeout = null;<br>                    func.apply(context,args)<br>                }, wait);<br>            }<br>        }<br>    }</p>
<p>}</p>
<p>四、函数防抖（dobounce）<br> function debounce (func, wait) {<br>         var timeout;<br>         return function() {<br>             var context = this;<br>             var args = arguments;<br>             clearTimeout(timeout);<br>             timeout = setTimeout(() =&gt; {<br>                 func.apply(context,args)<br>             }, wait);<br>         }<br>     }</p>
<p>五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</p>
<pre><code>Object.prototype.clone = function() {
  var newObject = this.constructor === Array ? [] : {}  //对象的深拷贝 获取对应的构造函数 [] 或者 {}
  for (let e in this) { //遍历对象的属性 in  this[e]
    newObject[e] = typeof this[e] === &apos;object&apos; ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型
  }
  return newObject
}
</code></pre><p>六、实现一个简单的Promise <a href="https://juejin.im/post/5b2f02cd5188252b937548ab" target="_blank" rel="noopener">https://juejin.im/post/5b2f02cd5188252b937548ab</a><br>class Promise {<br>  constructor (executor) {   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。<br>    this.status = ‘pending’,<br>    this.value = undefined;<br>    this.reason = undefined;<br>    // 成功存放的数组<br>    this.onResolvedCallbacks = [];<br>     // 失败存放法数组<br>     this.onRejectedCallbacks = [];<br>    let resolve = (value) =&gt; {<br>      if (this.status == ‘pending’) {<br>        this.status = ‘resolve’;<br>        this.value = value;<br>        this.onResolvedCallbacks.forEach(fn =&gt; fn())<br>      }<br>    }</p>
<pre><code>let reject = (reason) =&gt; {
  if (this.status == &apos;pending&apos;) {
    this.status = &apos;reject&apos;;
    this.reason = reason;
    this.onRejectedCallbacks.forEach(fn =&gt; fn())
  }
}
try{
  executor(resolve, reject);
} catch (err) {
  reject(err);
}
</code></pre><p>  }<br>  then (onFullFilled,onRejected) {<br>    if (this.status == ‘resolved’) {<br>      onFullFilled(this.value)<br>    }<br>    if (this.status == ‘rejectd’) {<br>      onRejected(this.reason);<br>    }<br>    if (this.status == ‘pending’) {<br>      this.onResolvedCallbacks.push(()=&gt;{<br>        onFullFilled(this.value);<br>      })<br>      this.onRejectedCallbacks.push(()=&gt; {<br>          onRejected(this.reason);<br>      })<br>  }</p>
<p>  }<br>}</p>
<p>const p = new Promise((resolve, reject) =&gt; {<br>  setTimeout(() =&gt; {<br>      resolve(‘hello world’)<br>  }, 1000);<br>})<br>p.then((data) =&gt;{<br>  console.log(data)<br>},(err) =&gt;{<br>  console.log(err);<br>})</p>
<p>七、发布订阅者模式（观察者模式）</p>
<p>var event = {}; // 发布者<br>event.clientList = [] //发布者的缓存列表</p>
<p>event.listen = function (fn) {  // 增加订阅者函数<br>  this.clientList.push(fn)<br>}</p>
<p>event.trigger = function () {  // 发布信息<br>  for (var i =0;i&lt;this.clientList.length;i++) {<br>    var fn = this.clientList[i];<br>    fn.apply(this, arguments);<br>  }<br>}</p>
<p>event.listen (function(time) {<br>  console.log(‘正式上班时间为：’ +time)<br>})<br>event.trigger (‘2018/7’)</p>
<p>八、手动写一个node服务器<br>const http = require(‘http’);<br>const fs = require(‘fs’);<br>const server = http.createServer((req,res) =&gt; {<br>    if (reu.url == ‘/‘) {<br>    const indexFile = fs.createReadStream(‘./index.html’)<br>    req.writeHead(200,{‘context-Type’:’text/html;charset = utf8})<br>    indexFile.pipe(res)<br>}<br>server.listen(8080)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/跨域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.tom">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="心永恒，梦已不再">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/跨域/" itemprop="url">跨域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T08:21:16+08:00">
                08:21:16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><ul>
<li>浏览器的安全机制： 同源策略：不同域禁止连接（域名、协议、端口号） </li>
</ul>
<p>解决方法：</p>
<ul>
<li>jsonp<ul>
<li>json with padding 跨域数据交互协议</li>
<li>协议要求：服务器端传递callback参数，前端需要与callback参数一致，才能获取传递的数据</li>
</ul>
</li>
<li>基于script标签实现跨域</li>
<li></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/working/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.tom">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="心永恒，梦已不再">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/working/" itemprop="url">工作安排</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T08:21:16+08:00">
                08:21:16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="8-27-第一天，混吃混喝-…"><a href="#8-27-第一天，混吃混喝-…" class="headerlink" title="8/27  第一天，混吃混喝 …."></a>8/27  第一天，混吃混喝 ….</h2><p>基本上涛哥（上司）给个甜枣打个棒子…，正常，深信服第一天工作确实不错，吃得好，喝的好，工作环境好，氛围比较融洽，就是刚来鸭梨优点大，下周就要demo了… </p>
<h2 id="8-28-第二天"><a href="#8-28-第二天" class="headerlink" title="8/28 第二天"></a>8/28 第二天</h2><p>任务：</p>
<ul>
<li>开始着手css样式， 看eslint规则  ok</li>
<li>买洗衣粉，衣服裤子，各种生活用品  no</li>
<li>每日笔记  ok</li>
<li>安排日程规划  no</li>
</ul>
<p>今天安排，全天看源码，看大佬以前的源码，和公司自己的文档，感觉公司自己的文档一定是某一个刚毕业的大学生写的，有点随意，错别字太多了，文档不清晰，还凑合着看源码才能看懂这个标签有啥子用，哎，不说了，心累…<br>还有大佬的源码确实很复杂，整个项目太大了，估计今年我就要待在这里面不出来了…<br>除了工作压力比较大之外，其他方面待遇确实不错的，饮食就非常满意，四个餐厅随便选，每个餐厅的伙食都不一样，刚开始都不知道怎么走，还是大佬带路，混吃混喝… 哎，就是舒服…..<br>还有一点需要吐槽了，中午午休，这是一大特色，可能只有我们技术部门的待遇吧，我不是很清楚，一到中午一点左右，整个技术部门一片漆黑… ，跟个鬼屋一样，吓死人.. 上班了，不打字了….</p>
<h2 id="8-29-第三天"><a href="#8-29-第三天" class="headerlink" title="8/29 第三天"></a>8/29 第三天</h2><ul>
<li>开始些项目了吧..<br>额，然而，并没有，今天还是帮我开了个gitlab…<br>今天总算拿到工卡了，真实太好了…..终于有了自己可以随意吃饭了，嘿嘿嘿….<br>明天开始着手写项目了，我现在还是有点对vue有点迷茫，确实有好多东西忘记了….<br>不知道怎么学习了，文档又有点迷茫，看不懂，我决定先把工作完成吧，毕竟这才是主力活，干完了才可以好好着手写自己的项目….<br>明天努力加油！！ 争取多吃点！！嗯嗯，没错， 该买洗衣粉了，衣服还没洗呢….<br>周末….  这周末没时间了，要加班了，周末交项目…. 今天周三，明天周四，争取完成那个页面，一天时间应该可以完成99.99%  嗯嗯，应该…<br>然后中午买个枕头….  最好自己买本草稿纸…..<br>自己有笔，就不买了，那就买一只铅笔，    额，我是不是要快递我那几本书呢？？ 我会看么 ？？ 额，会吧， 还是带过来深圳吧… 毕竟在学校放着也没事，带过来看会比较好，  我中午还是不要睡觉啦，一个半小时，我可以先完成任务半个小时，还有一个小时的话，喝杯茶，看书吧，我时间不够啊，争取节约每一个小时，工作太累了，别人的代码思路确实和自己的有很大的不同，还是要靠近大佬思路才可以啊….  大佬都快转正了，我还是在实习的路上一去不复返啊…. 好几天没有打王者了，没一点意思了…. 每天都是看文档，看文档，看大佬源码，明天就要正式接手项目了，我现在连怎么拉分支都不是很清楚….十几个分支，这个分支写一点，那个分支写一点，然后合并到另外一个分支，另外一个分支还没写完…额，晕晕晕…<br>今天循环了一天的the truth that you leave 确实不错，挺有感觉的，适合敲代码，心情平静，专注的时候听歌，不过听久了还是有点耳朵审美疲劳…  下次换首歌，…. </li>
</ul>
<h2 id="8-30-第四天"><a href="#8-30-第四天" class="headerlink" title="8/30 第四天"></a>8/30 第四天</h2><ul>
<li>项目开始着手写了，前期看文档我都没有看懂，什么破文档，哎，注释什么的都没有，基本都是看源码和猜想来实现你的需求，一个小小的icon都没有….  我鄙视这个写文档的开发者… 所以，我决定，先把工作做完，文档什么的先放一边，工作做完，我把文档修饰一下，不然要累死…<br>还是说说今天的项目吧。。。 人手不够，时间紧迫， 需求很反人类，代码量贼多，修改的地方太多，注释太少，格式不规范，找不到具体的业务，页面…   这个项目问题比较大…   还的好好的学习，努力一下，加班一下… 然后，上班的第一个周末，  不存在周末的…   每个月第一周上班，工作任务周末截止，要展示效果….<br>我还能说什么?? 哎哎哎，还是加班太严重了，其实也不能说加班严重，就是上面分配的任务太多，按照正常工作时间上你根本不可能完成，即使你是大佬也不太可能，除非你是超人….   你看，普通的界面样式，要像素还原非常花时间，你必须一点点调，这个很耗耐心和时间，还有需求，我现在还不敢写重要的需求，刚来不到五天，整个框架的核心代码不敢随意动，现在看得懂看不懂还是俩嘛事…   哪敢随意更改 ？？？<br>今天晚上睡觉比较晚，拖到了十二点….  唉，起来都有点打呼噜….    还是要好好奋斗啊….<br>今天终于鼓起勇气和隔壁的女孩子聊天，嘿嘿，还是很开心的，那个女孩子也是刚来的俩个月，这个sds毕竟太年轻，才建立时间仅仅半年时间，每个人的工作时间都不是很长，都是80后 90后的样子， 年轻团队就是好，她也是一个苦命的娃，本来写c的，俩个月前，突然调到sds，然后看一天php，直接上手….    倒霉的孩纸，简直跨专业，还要专业的写代码….    我不知道我写前端的是不是某一天突然调到写C了，哈哈哈呵呵呜呜….   不写了，该上班了，每天早上写昨天的随记，这个习惯感觉不错..  以后继续坚持吧….    还有，我该洗澡了… 需要买衣服买洗衣粉了….  袜子都不够穿了… 话说公司的快递在哪里，我怎么找不到 ？？   …  回去问一下吧…. 昨天的宵夜吃的太饱，今天早上感觉有点胀胀的…….  一分钱的宵夜果然还是忍不住不吃啊，哈哈哈….</li>
</ul>
<h2 id="8-31-第五天"><a href="#8-31-第五天" class="headerlink" title="8/31 第五天"></a>8/31 第五天</h2><p>有好多话说，但是时间不够了，我尽快说完。<br>今天是我优化页面的重点时间，我已经把页面优化了有七成左右，主要还是差echart的那个模块还没有写完，其他小细节我写完写个再改动一下下，项目经理昨天突然发消息给我，说我写的咋样，我说今天就能完成… 看来还没有完成， 页面效果我觉得至少8.5成后才可以封住那些测试的嘴…. 可是我觉得只完成了七成左右，还得加油啊。。。。。 echart偶第一次接触啊，参数太多，有时候不需要看懂什么意思，直接复制粘贴就行… 好暴力…   我喜欢..<br>工作上的事情我就说完了，还有就剩下生活上的事情了，我遇到了一件十分无语的事情，昨天吃完晚饭，准备回去好好写完最后的工作时，天晓得我的电脑发生了什么事情… 电脑突然红屏，对没错，不是蓝屏，是红屏..!!  更恐怖的是，显示俩个按钮，重装还是格式化？？？ what facking !!  我怎么选，写了这么久的样式后天就要提交了你却说要重装？？ 吓得我好怕怕怕的，机智的我果断关机冷静一下，然后小心翼翼的开机…. 嘿，好了。。。。没有红屏了，额。。。。你页面闪烁是怎么回事？？  眼睛好痛…..  额还好，问题不大，然后随便瞎几把乱搞了半个小时… 尼玛！！ 怎么还是这样？？  最后大佬一看，笨啊，闪烁你改不了你就用什么覆盖它啊，主机不是有控制颜色的么，你随便减少一下蓝色亮度什么的，然后下载一个f.ul之类的保护色软件的直接覆盖闪烁不就行了，反正你闪烁这么轻微…. 好有道理的昂志…  然后我又搞了半小时….. 原谅饿哦对台式机完全不懂….<br>哎呦喂，没时间了，我要上班了，每个月的第一个礼拜周六都要上班… 走了，拜拜  </p>
<h2 id="9-5-工作忙，没时间写…"><a href="#9-5-工作忙，没时间写…" class="headerlink" title="9/5 工作忙，没时间写…"></a>9/5 工作忙，没时间写…</h2><p>工作太忙了，没有时间写日记了，以后就随便写吧….   </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/university/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.tom">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="心永恒，梦已不再">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/university/" itemprop="url">大学三年了，我干了什么 ？？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T08:21:16+08:00">
                08:21:16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这是我自己随手写的，各位看官，看看就行，别较真….</p>
</blockquote>
<p>从初入大学的懵懂，到现在临门一脚就要离校实习的怅然若失，突然觉得，过去一直活在自己给自己营造的虚幻温床中，还天真地以为自己各方面都不错。现在应该是渐渐梦醒了吧，越来越看清自己，其实除了会勤奋学习努力工作之外，其它方面毫无进展：不读书，头脑简单；不懂旅行，见识少；惧怕交际，没朋友；不懂生活，没情调… … … … … … BUT，懊悔是一回事，还是得做一只打不死的小强！调整心态，从多读书，好好健身开始，然后暑假突破自己，去做义工，去学K歌，生活是可以很有趣的呐！扎油啊onion！</p>
<h4 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h4><p>大一，人生黄金期的起点，你所认识的人和所经历过的事情都是我以前在学校学习不到的，虽然当中有序许许多多的坑…<br>刚上大学的那几天，我也是差不多快忘记了俩年前的事情了，只记得大概的轮廓，趁着现在有时间，赶紧记下来，以后说不定回头翻俩下，还能笑笑<br>过之…<br>还记得去上大学的那一天，家里父母不怎么会坐车，（晕车，其实我也比较晕车），那时候头晕脑胀的，迷迷糊糊的到了东门，又是公交又是打的，晕的死呦..  大包小包的全部提到了东门口，一看，我去，一个人都木有看到… 说好的接人了？？ 这学校有毒，然后行李一扔，自己一个人在学校溜达了半个小时，知道学校的每个区域基本位置了，其中还遇到了同班同学，一个女妹纸，挺漂亮的，谁叫我那时候那么腼腆了，没有过去搭讪，哎，真几把想抽自己一下，也没有那么多麻烦了， 路边问了一个帅哥，还好小哥帮忙，又是搬行李的，又是指路的，终于到了研一楼，嘿，还挺高的，通知书一看，嗯嗯，研一836，可以可以，八楼，6的飞起，到了寝室谢了小哥，开始整理房子，嘿，我是第一个到….舒服…选了一个比较好的位置，直接整理，….这后面就是陆陆续续的来了好多同学，室友都来了，也不清楚什么了，这里告一段落。。。<br>然后就是军训了，天知道这破几把学校为什么军训…. 还特么这么热的天气… 每天早上五点就要起床，<br>雄性荷尔蒙的快速分泌提供了充足的动力去寻找另一半，</p>
<h4 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h4><h4 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h4><h4 id="大四准备…"><a href="#大四准备…" class="headerlink" title="大四准备…"></a>大四准备…</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/talk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.tom">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="心永恒，梦已不再">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/talk/" itemprop="url">面试过程总结  -- Web前端攻城狮</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T08:21:16+08:00">
                08:21:16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这篇文章是我这半个月的面试总结，其中有一些不好说的话，我这里就是随口说说而已，各位看官不要介意，还有就是，我只是一个菜鸟，您看完之后一笑过之就行…</p>
</blockquote>
<h3 id="初次面试是一个痛并快乐的事"><a href="#初次面试是一个痛并快乐的事" class="headerlink" title="初次面试是一个痛并快乐的事"></a>初次面试是一个痛并快乐的事</h3><p>初次面试，怎么生活呢，第一步非常难，就像和初恋第一次牵手一样，激动着，又胆怯着，想牵手又怕对方拒绝，每次伸手到一半又缩回去，来来回回好几次，渴望和害怕在脑海里SOLO….<br>我的第一次面试还是那么记忆犹新（由于不知道自己的水平，我刚开始投简历的都是小型创业公司，一般也就20个人以下的小团体），它是北京的一家小型创业公司，约定好的是下午三点电话面试，那天上午，整整一上午疯狂看书背重点，六点起床，早饭都没吃，一直看书看文档，把文档里了解的东西全部梳理一遍，然后把平常写的笔记和重点全部过滤一下，复杂的东西就不要深究了，特别是那些没有接触的算法，理解就行….<br>就这样，高考似的疯狂压榨和鸭梨，整个人搞得头晕脑胀，昏昏欲睡，到了中午十二点，没有一点点食欲，相当想睡，可一想到下午就要面试，还敢睡觉？？还睡得着？？那一天简直好像回到了高三的时候，生不如死….<br>然后最煎熬的时候到了，中午到了12点，想点一份外卖，又不知道吃啥，随便点了一份黄焖鸡，爆辣，想来点辣椒刺激脑袋清醒一下,然后继续看书，后来越来越看不下去了，又一直狠下心看下去，边吃饭边看书，不知道我是怎么度过的这俩个小时，反正我是忘记了，太痛苦，不太记起来了…..<br>终于，TMD面试终于来了，我突然想不面试了，就想好好的睡一觉，然后什么都不管，真想拒绝这个面试，真实好累…<br>还是理智战胜了心灵，面试问的题目我都忘记了，鬼知道那时候怎么聊的，反正我只知道，面试后我就觉得GG了，然后直接睡觉到晚上十点半，什么都不管了，醒来直接叫两份外卖，看着直播小姐姐，吃着麻辣烫，什么面试的都GG去吧….，第二天十一点，还是老老实实的投简历…</p>
<h3 id="第二次面试"><a href="#第二次面试" class="headerlink" title="第二次面试"></a>第二次面试</h3><p>这次面试不是跟第一次一样的电话面试，而是先给一个题目做，然后提交给对方看源码和效果，最后问思想。由于对方公司比较有名，为了双方的某些利益和声誉着想，我就说A公司和B公司吧…<br>A公司的面试过程比较直接，二话不说先抛出一个贼几儿无语的题目给我做，不限时间，越快越好….（后来我才知道，越快越好其是没什么意思，并不真的越快越好….）当时也是年轻气盛，A公司确实挺有名的，也为了更好的展现自己的实力，我没有使用简单粗暴的jquery和vue，我直接使用纯手js撸出这个项目，每天要花掉十小时搞这个事情，整整一个礼拜，功夫不负有心人啊，写完了，一提交，“额，你这个不行啊，太复杂了。。。”  excuse me ????  效果一毛一样你居然说太复杂？？ 怪我喽？？ 你自己要我写的需求，我能咋办？？ 代码我都优化了三遍了，你还要我咋样，那时候感觉受到了上万吨的暴击伤害，彻底受伤了，黄焖鸡都不想吃了，B站小姐姐看的都没意思了，王者荣耀上王者都没感觉了，贼烦…..    过了好久，面试官说，“额，你这个功能是实现了，但是我要的是联动效果，而不是备份效果….” 额，我甚至不想理他了，最后，口嫌体正直，还是写了……一周……<br>现在，终于可以给个面试机会了吧，就在我满心欢喜的时候，准备六神装妲己秒人的时候，草丛中跳出了六个大汉….   面试官居然让我社招，把我踢到C公司社招，然后简历上造假项目经验。。。我就呵呵了，大三学生哪来的勇气社招，哪来的经验,哪来的这么多的项目经验??? 后来我彻底不了他了，大公司不要我早说嘛，干嘛浪费我俩个礼拜时间，你不知道大三投简历面试很缺时间么?? —– 这一次我身体彻底吃不消了，高强度的用脑和对方的无情刺激，我最后一丝防线崩溃了，彻底睡晕过去了，我记得好像从中午俩点半睡到下一天的下午六点左右，将近28个小时，还好锻炼了身体，有俩块腹肌的男人，还能醒来，这次，彻底给了我教育了，也一觉大悟了….面试是不公平的，但是我可以拒绝的，中国公司那么多，我非要去你公司么？？ 你公司不就是那啥啥很强么，那又咋样，哥还不待见了，我一个大三小伙子，没有优异的学校背景，没有太过帅气的脸，也不是一个学霸，但是我就是不面试你这家，咋的？？        </p>
<h4 id="第三次到以后的面试"><a href="#第三次到以后的面试" class="headerlink" title="第三次到以后的面试"></a>第三次到以后的面试</h4><p>经过前俩次的面试，我制定了一些基本 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/jsCodingStyle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.tom">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="心永恒，梦已不再">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/jsCodingStyle/" itemprop="url">js编码风格</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T08:21:16+08:00">
                08:21:16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>借鉴多位大佬的文章和自己的心得体会总结而成，为广大程序猿提供优质的学习文章渠道，js编码风格的统一性有助于您更好的编码，同事也能方便的阅读您写的优质code。</p>
<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>每一行的层级由4个空格组成，避免使用Tab进行缩进。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">if (true) &#123;</span><br><span class="line">    doSomeThing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="行的长度"><a href="#行的长度" class="headerlink" title="行的长度"></a>行的长度</h4><p>每行长度不应超过80个字符。如果一行超过80个字符，应当在一个运算符后换行。下一行应当增加两级缩进（8个字符）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">doSomeThing(argument1, argument2, aegument3, argument4,</span><br><span class="line">        argument5);</span><br><span class="line"></span><br><span class="line">// 不好的写法：第二行只有4个空格的缩进</span><br><span class="line">doSomeThing(argument1, argument2, aegument3, argument4,</span><br><span class="line">    argument5);</span><br></pre></td></tr></table></figure></p>
<h4 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h4><ol>
<li>字符串应当始终使用双引号且保持一行，避免在字符串中使用斜线另起一行。</li>
<li>数字应当使用十进制整数，科学计算法表示整数，十六进制整数，或者十进制浮点小数，小数前后应当至少保留一位数字。避免使用八进制直接量。</li>
<li>特殊值null除了下述情况下应当避免使用。<ul>
<li>用来初始化一个变量，这个变量可能被赋值为一个对象。</li>
<li>用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。</li>
<li>当函数的参数期望是对象时，被用作参数传入。</li>
<li>当函数的返回值期望是对象时，被用作返回值传出。</li>
<li>避免使用特殊值undefined。判断一个变量是否定义应当使用typeof操作符。</li>
</ul>
</li>
</ol>
<h4 id="运算符间距"><a href="#运算符间距" class="headerlink" title="运算符间距"></a>运算符间距</h4><p>二元预算符前后必须使用一个空格来保持表达式的整洁。操作符包括赋值运算符和逻辑运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">for (var i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    process(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：丢失了空格</span><br><span class="line">for (var i=0; i&lt;count; i++) &#123;</span><br><span class="line">    process(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="括号间距"><a href="#括号间距" class="headerlink" title="括号间距"></a>括号间距</h4><p>当使用括号时，紧接左括号之后和紧接右括号之前不应该有空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">for (var i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    process(i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 不好的写法：参数两边有额外的空格</span><br><span class="line">for (var i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    process( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h4><p>对象直接量应当有如下格式。</p>
<ul>
<li>起始左花括号应当同表达式保持同一行。</li>
<li>每个属性的名值对应当保持一个缩进，第一个属性应当在左花括号后另起一行。</li>
<li>每个属性的名值对应当使用不含引号的属性名，其后紧跟一个冒号（之前不舍空格），其后是值。</li>
<li>倘若属性值是函数类型，函数体应当在属性名之下另起一行，而且其前后均应保留一个空行。</li>
<li>一组相关的属性前后可以插入空行以提升代码的可读性。</li>
<li>结束的右花括号应当独占一行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">var object = &#123;</span><br><span class="line"></span><br><span class="line">    key1: value1,</span><br><span class="line">    key2: value2,</span><br><span class="line"></span><br><span class="line">    func: function() &#123;</span><br><span class="line">    // doSomeThing</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    key3: value3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不好的写法：不恰当的缩进</span><br><span class="line">var object = &#123;</span><br><span class="line">        key1: value1,</span><br><span class="line">        key2: value2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">// 不好的写法：函数体周围缺少空行</span><br><span class="line">var object = &#123;</span><br><span class="line"></span><br><span class="line">    key1: value1,</span><br><span class="line">    key2: value2,</span><br><span class="line">    func: function() &#123;</span><br><span class="line">    // doSomeThing</span><br><span class="line">    &#125;,</span><br><span class="line">    key3: value3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当对象字面量作为函数参数时，如果值是变量，起始花括号应当同函数名在同一行。所有其余先前列出的规则同样适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">doSomeThing(&#123;</span><br><span class="line">    key1: value1,</span><br><span class="line">    key2: value2</span><br><span class="line">&#125;);</span><br><span class="line">// 不好的写法：所有代码在一行上</span><br><span class="line">doSomeThing(&#123; key1: value1, key2: value2 &#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>使用简洁明了注释有助于他人理解你的代码。如下情况应当使用注释。</p>
<ul>
<li>代码晦涩难懂。</li>
<li>可能被误认为错误的代码。</li>
<li>必要但不明显的针对特定浏览器的代码。</li>
<li>对于对象、方法或者属性，生成文档是有必要的（使用恰当的文档注释）。<h5 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h5>单行注释应当用来说明一行代码或者一组相关的代码。单行注释可能有三种使用方式。</li>
<li>独占一行的注释，用来解释下一行代码。</li>
<li>在代码行的尾部的注释，用来解释它之前的代码。</li>
<li>多行，用来注释掉一个代码块。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">if (condition) &#123;</span><br><span class="line"></span><br><span class="line">    // 如果代码执行到这里，则表明通过了所有安全检查</span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：注释之前没有空行</span><br><span class="line">if (condition) &#123;</span><br><span class="line">    // 如果代码执行到这里，则表明通过了所有安全检查</span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：错误的缩进</span><br><span class="line">if (condition) &#123;</span><br><span class="line"></span><br><span class="line">// 如果代码执行到这里，则表明通过了所有安全检查</span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：应当使用多行注释</span><br><span class="line">// 这段代码进行**判断</span><br><span class="line">// 然后执行</span><br><span class="line">if (condition) &#123;</span><br><span class="line"></span><br><span class="line">    // 如果代码执行到这里，则表明通过了所有安全检查</span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 好的写法：在行尾注释时，代码结尾和注释间应保留一个空格</span><br><span class="line">if (condition) &#123;</span><br><span class="line"></span><br><span class="line">    // 如果代码执行到这里，则表明通过了所有安全检查</span><br><span class="line">    allowed(); // 执行**函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：代码和注释间没有足够的空格</span><br><span class="line">if (condition) &#123;</span><br><span class="line"></span><br><span class="line">    // 如果代码执行到这里，则表明通过了所有安全检查</span><br><span class="line">    allowed();// 执行**函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 好的写法：在注释掉一个代码块时，应联系使用单行注释，多行注释不应当使用在此种情况下。</span><br><span class="line">// if (condition) &#123;</span><br><span class="line">//     allowed();//执行**函数</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h5><p>多行注释应当在代码需要更多文字去解释的时候使用。每个多行注释都至少有如下三行：</p>
<ul>
<li>首行仅仅包括/*注释开始。该行不应当有其他文字。</li>
<li>接下来的行以*开头并保持左对齐。这些可以有文字描述。</li>
<li>最后一行以*/开头并同先前行保持对齐。也不应有其他文字。</li>
<li>多行注释的首行应当保持同它描述代码的相同层次的缩进。后续的每行应当有同样层次的缩进并附加一个空格（为了适当保持*字符的对齐）。每一个多行代码之前应当预留一个空行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法、</span><br><span class="line">if (condition) &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * 如果代码执行到这里</span><br><span class="line">    * 说明通过了所有的安全检测</span><br><span class="line">    */</span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="注释声明"><a href="#注释声明" class="headerlink" title="注释声明"></a>注释声明</h5><p>注释有时候也可以用来给一段代码声明额外的信息。这些声明的格式以单个单词打头并紧跟一个冒号。可以使用的声明如下。</p>
<ul>
<li>TODO：说明代码还未完成。应当包含下一步要做的事情。</li>
<li>HACK：表明代码实现走了一个捷径。应当包含为何使用hack的原因。这也可能表明该问题可能会有更好的解决办法。</li>
<li>XXX：说明代码是有问题的并应当尽快修复。</li>
<li>FIXME：说明代码是有问题的并应尽快修复。重要性略次于XXX。</li>
<li>REVIEW：说明代码在任何可能的改动都需要评审。</li>
<li>这些声明可能在一行或者多行注释中使用，并且应当遵循同一般注释类型相同的格式规则。</li>
</ul>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>变量和函数在命名时应当小心。命名应紧限于数字字母字符，某些情况下可以使用下划线(_)。最好不要在任何命名中使用美元符号($)或者反斜杠()。<br>变量命名应当采用驼峰命名格式，首字母小写，每个单词首字母大写。变量名的第一个单词应当是一个名词(而非动词)以避免同函数混淆。不要在变量名中使用下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">var accountNumber = &quot;test001&quot;;</span><br><span class="line"> </span><br><span class="line">// 不好的写法：大写字母开头</span><br><span class="line">var AccountNumber = &quot;test001&quot;;</span><br><span class="line"></span><br><span class="line">// 不好的写法：动词开头</span><br><span class="line">var getAccountNumber = &quot;test001&quot;;</span><br><span class="line"></span><br><span class="line">// 不好的写法：使用下划线</span><br><span class="line">var account_number = &quot;test001&quot;;</span><br></pre></td></tr></table></figure></p>
<p>函数名也应当采用驼峰命名格式。函数名的第一个单词应当是动词（而非名词）来避免同变量混淆。函数名中最好不要使用下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：大写字母开头</span><br><span class="line">function DoSomething() &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：名词开头</span><br><span class="line">function something() &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：使用下划线</span><br><span class="line">function do_something() &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数–通过new运算符创建新对象的函数–也应当以驼峰格式命名并且首字符大写。构造函数名称应当以非动词开头，因为new代表着创建一个对象实例的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">function MyObject() &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：小写字母开头</span><br><span class="line">function myObject() &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：使用下划线</span><br><span class="line">function my_object() &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：动词开头</span><br><span class="line">function getMyObject() &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>常量（值不会被改变的变量）的命名应当是所有大写字母，不同单词之间单个下划线隔开。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">var TOTAL_COUNT = 10;</span><br><span class="line"></span><br><span class="line">// 不好的写法：驼峰形式</span><br><span class="line">var totalCount = 10;</span><br><span class="line"></span><br><span class="line">// 不好的写法：混合形式</span><br><span class="line">var total_COUNT = 10;</span><br></pre></td></tr></table></figure></p>
<p>对象的属性同变量的命名规则相同。对象的方法同函数的命名规则相同。如果属性或者方法是私有的，应当在之前加上一个下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">var object = &#123;</span><br><span class="line">    _count: 10,4 </span><br><span class="line">    _getCount: function() &#123;</span><br><span class="line">        return this._count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="变量与函数声明"><a href="#变量与函数声明" class="headerlink" title="变量与函数声明"></a>变量与函数声明</h4><h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><p>所有的变量在使用前都应当事先定义。变量定义应当放在函数开头，使用一个var表达式每行一个变量。除了首行，所有行都应当多一层缩进以使变量名能够垂直方向对齐。变量定义时应当初始化，并且赋值操作符应当保持一致的缩进。初始化的变量应当在未初始化变量之前。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line"> var count = 10,</span><br><span class="line">     name = &quot;jeri&quot;,</span><br><span class="line">     found = false,</span><br><span class="line">     empty;</span><br></pre></td></tr></table></figure></p>
<h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>函数应当在使用前提前定义。一个不是作为方法的函数（也就是说没有作为一个对象的属性）应当使用函数定义的格式（不是函数表达式和Function构造器格式）。函数名和开始圆括号之间不应当有空格。结束的圆括号和右边的花括号之间应当留一个空格。右侧的花括号应当同function关键字保持同一行。开始和结束括号之间不应该有空格。参数名之间应当在逗号之后保留一个空格。函数体应当保持一级缩进。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">function outer() &#123;</span><br><span class="line">    var count = 10,</span><br><span class="line">        name = &quot;jeri&quot;,</span><br><span class="line">        found = false,</span><br><span class="line">        empty;</span><br><span class="line">    function inner() &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用inner()的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>匿名函数可能作为方法赋值给对象，或者作为其他函数的参数。function关键字同开始括号之间不应有空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">object.method = function() &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不好的写法：不正确的空格</span><br><span class="line">object.method = function () &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>立即被调用的函数应当在函数调用的外层用园括号包裹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 好的方法</span><br><span class="line">var value = (function() &#123;</span><br><span class="line"></span><br><span class="line">    // 函数体</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        message:&quot;hi&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>严格模式应当仅限在函数内部使用，千万不要在全局使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 不好的写法：全局使用严格模式</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 好的写法</span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line"> </span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><p>给变量赋值时，如果右侧是含有比较语句的表达式，需要用圆括号包裹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">var flag = (i &lt; count);</span><br><span class="line"></span><br><span class="line">// 不好的写法：遗漏圆括号</span><br><span class="line">var flag = i &lt; count;</span><br></pre></td></tr></table></figure></p>
<h5 id="等号运算符"><a href="#等号运算符" class="headerlink" title="等号运算符"></a>等号运算符</h5><p>使用===（严格相等）和!==（严格不相等）代替==（相等）和!=（不等）来避免弱类型转换错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">var same = (a === b);</span><br><span class="line"></span><br><span class="line">// 好的写法</span><br><span class="line">var same = (a == b);</span><br></pre></td></tr></table></figure></p>
<p>三元运算符应当仅仅用在条件赋值语句中，而不要作为if语句的替代品。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">var value = condition ? value1 : value2;</span><br><span class="line"></span><br><span class="line">// 不好的写法：没有赋值，应当使用if表达式</span><br><span class="line">condition ? doSomething() : doSomethingElse;</span><br></pre></td></tr></table></figure></p>
<h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><h5 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h5><p>每一行最多只包含一条语句。所有简单的语句都应该以分号(;)结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">count++;</span><br><span class="line">a = b;</span><br><span class="line"></span><br><span class="line">// 不好的写法：多个表达式写在一行</span><br><span class="line">count++; a = b;</span><br></pre></td></tr></table></figure></p>
<h5 id="返回语句"><a href="#返回语句" class="headerlink" title="返回语句"></a>返回语句</h5><p>返回语句当返回一个值的时候不应当使用圆括号包裹，除非在某些情况下这么做可以让返回值更容易理解。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return;</span><br><span class="line"></span><br><span class="line">return collection.size();</span><br><span class="line"></span><br><span class="line">return (size &gt; 0 ? size : defaultSize);</span><br></pre></td></tr></table></figure></p>
<h5 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a>复合语句</h5><p>复合语句是大括号括起来的语句列表。</p>
<ul>
<li>括起来的语句应当较复合语句多缩进一个层级。</li>
<li>开始的大括号应当在复合语句所在行的末尾；结束的大括号应当独占一行且同复合语句的开始保持同样的缩进。</li>
<li>当语句是控制结构的一部分时，诸如if或者for语句，所有语句都需要用大括号括起来，也包括单个语句。这个约定使得我们更方便地添加语句而不用担心忘记加括号而引起bug。</li>
<li>像if一样的语句开始的关键词，其后应该紧跟一个空格，起始大括号应当在空格之后。<h5 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h5>if 语句应当是下面的格式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; else if (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>绝不允许在if语句中省略花括号。<br>// 好的写法<br>if (condition) {<br>    doSomething();<br>}</p>
<p>// 不好的写法：不恰当的空格<br>if (condition){<br>    doSomething();<br>}</p>
<p>// 不好的写法：所有代码都在一行<br>if (condition) { doSomething(); }</p>
<p>// 不好的写法：所有代码都在一行且没有花括号<br>if (condition) doSomething();</p>
<h5 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h5><p>for类型的语句应当是下面的格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (initialization; condition; update) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (variable in object) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>for语句的初始化部分不应当有变量声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (initialization; condition; update) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (variable in object) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>for语句的初始化部分不应当有变量声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 好的方法</span><br><span class="line">var i,</span><br><span class="line">    len;</span><br><span class="line"></span><br><span class="line">for (i=0, len=0; i &lt; len; i++) &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：初始化时候声明变量</span><br><span class="line">for (var i=0, len=0; i &lt; len; i++) &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法：初始化时候声明变量</span><br><span class="line">for (var prop in object) &#123;</span><br><span class="line">    // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当使用for-in语句时，记得使用hasOwnProperty()进行双重检查来过滤对象的成员。</p>
<h5 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h5><p>while 类的语句应当是下面的格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="do-语句"><a href="#do-语句" class="headerlink" title="do 语句"></a>do 语句</h5><p>do 类的语句应当是下面的格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; while (condition);</span><br></pre></td></tr></table></figure></p>
<h5 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h5><p>switch 类的语句应当是如下格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch (expression) &#123;</span><br><span class="line">    case expression:</span><br><span class="line">        statements</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>switch下的第一个case都应当保持一个缩进。除第一个之外包括default在内的每一个case都应当在之前保持一个空行。<br>每一组语句（除了default）都应当以break、return、throw结尾，或者用一行注释表示跳过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">switch (value) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        /* falls through */</span><br><span class="line"></span><br><span class="line">    case 2:</span><br><span class="line">        doSomething();</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case 3:</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        throw new Error(&quot;Some error&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果一个switch语句不包含default情况，应当用一行注释代替。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">switch (value) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        /* falls through */</span><br><span class="line"></span><br><span class="line">    case 2:</span><br><span class="line">        doSomething();</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case 3:</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        // 没有default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="try-语句"><a href="#try-语句" class="headerlink" title="try 语句"></a>try 语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; catch (variable) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; catch (variable) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.tom">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="心永恒，梦已不再">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/hello-world/" itemprop="url">一个喜欢吃鸡的王者</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T08:21:16+08:00">
                08:21:16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>生活不易，该笑的时候那就笑大声吧</li>
</ul>
<h2 id="生活不止眼前的苟且，还有未来的苟且"><a href="#生活不止眼前的苟且，还有未来的苟且" class="headerlink" title="生活不止眼前的苟且，还有未来的苟且"></a>生活不止眼前的苟且，还有未来的苟且</h2><h3 id="苟，是一种态度"><a href="#苟，是一种态度" class="headerlink" title="苟，是一种态度"></a>苟，是一种态度</h3><p>也许你并不同意我的看法，但是，苟，确实是我们每一天的写照…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/eatChicken/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.tom">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="心永恒，梦已不再">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/eatChicken/" itemprop="url">十年后，我还敲代码么？？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T08:21:16+08:00">
                08:21:16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/dt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.tom">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="心永恒，梦已不再">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/dt/" itemprop="url">节流和防抖</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T08:21:16+08:00">
                08:21:16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><ul>
<li>单位时间内只能执行一次，必须执行，先执行</li>
<li>页面无限制高度刷新请求页面ajax请求、</li>
</ul>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ul>
<li>单位时间内只执行一次，不一定执行，后执行</li>
<li>onresize、mousemove、mouseout、</li>
</ul>
<h2 id="闭包…args参数问题"><a href="#闭包…args参数问题" class="headerlink" title="闭包…args参数问题"></a>闭包…args参数问题</h2><ul>
<li>可能与上一级作用域的参数this有关</li>
<li>可能内置</li>
<li>es6特点</li>
</ul>
<h2 id="减法操作"><a href="#减法操作" class="headerlink" title="-减法操作"></a>-减法操作</h2><ul>
<li>如果有一个操作数是字符串，布尔值，null，undefined，则在后台调用Number()将其转化为数值，再进行减法运算（这里跟上一篇:Javascript中加法运算符总结要区分）。<br>如果有一个操作数是对象，则调用对象的valueOf()方法取得表示该对象的数值。如果得到的值是NaN，减法结果是NaN。如果对象没有valueOf()方法，调用它的toString()方法，并将得到的字符串转化为数值.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/css/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.tom">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="心永恒，梦已不再">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/css/" itemprop="url">CSS学习之路---路漫漫，情深深</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T08:21:15+08:00">
                08:21:15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="css盒模型问题"><a href="#css盒模型问题" class="headerlink" title="css盒模型问题"></a>css盒模型问题</h4><ul>
<li>IE盒模型：width = 固定、border、padding和contentwidth里，如果过多则会向外挤…</li>
<li>W3C盒模型： width = content ,整体的宽度是自定义宽度 + border +padding</li>
<li>可通过box-size:(border-box、content-box)来修改盒模型</li>
</ul>
<h4 id="前端一像素问题"><a href="#前端一像素问题" class="headerlink" title="前端一像素问题"></a>前端一像素问题</h4><ul>
<li>关键点： transform: scale() / scaleX / scaleY  和 transform-origin</li>
<li>一： 如果一个盒子的边框缩放的话(一般设置图片边框)，先把宽高设置为原来的俩倍，边框一像素，然后缩放</li>
<li>如果是定义一条分割线的话，直接width:200% height:0 border-top: 1px solid black; </li>
</ul>
<h4 id="transition、animation、transform区别"><a href="#transition、animation、transform区别" class="headerlink" title="transition、animation、transform区别"></a>transition、animation、transform区别</h4><ul>
<li>transform 描述了元素静态样式,比如缩放、位移、旋转、最终实现的是一个固定不动的效果，而transtition和animation实现动画效果,所以transfrom经常配合后两种使用，在页面中实现五毛特效….</li>
<li>transition和anmination的不同点主要有四方面:   <ul>
<li>触发条件不同，transition由事件触发，比如点击、hover、js控制等等,而animation类似gif动态图，立即触发…</li>
<li>是否可以循环， animation可以设置循环播放次数(n)或者无线循环(infinite)</li>
<li>精确性，animation可以设置每一帧样式、时间，精确度贼高，而transition只能设置头尾from  to</li>
<li>与js的交互的紧密程度,animation与js交互不是很紧密，一般通过增减删除class来实现交互。而transition和js的交互就非常棒的，js这是变化（在from 和to中设置）,而transtion赋值动画效果，天作之合..</li>
</ul>
</li>
</ul>
<h4 id="不定宽高的div居中"><a href="#不定宽高的div居中" class="headerlink" title="不定宽高的div居中"></a>不定宽高的div居中</h4><ul>
<li>flex布局：  display：flex; justify-content: center; align-item: center;</li>
<li>使用transform:translate控制位置：  父元素相对定位，子元素绝对定位、top:50%; left:50%, transfrom:translate(-50%, -50%);</li>
<li>display:table-cell布局   父元素display：table-cell、text-align:center;vertical-align:middle;  子元素：display:inine-block布局</li>
<li>最新的布局display：box布局；主要是用来解决div的横向布局问题，以前是通过inline-block、float来设置，现在可以使用box布局方式。父级:display:box; 子级：box-pack: center( 水平居中对齐);.box-align:center (垂直居中对齐)  遗憾的是，所有浏览器都不支持这个属性，必须添加前缀才可以….</li>
<li>浮动也可以实现居中，核心，包裹一层容器，容器设置margin: 0 auto; </li>
</ul>
<h4 id="父子高度已知-居中"><a href="#父子高度已知-居中" class="headerlink" title="父子高度已知 居中"></a>父子高度已知 居中</h4><ul>
<li>父级相对定位，子级绝对定位，left = (fatherWidth - sonWidth)/2; top: (fatherHeight-sonHeight)/2</li>
<li>利用行高line-height： 父级高度…  子级 margin: 0 auto;</li>
<li><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4></li>
<li><a href="https://juejin.im/post/5a954add6fb9a06348538c0d" target="_blank" rel="noopener">https://juejin.im/post/5a954add6fb9a06348538c0d</a></li>
</ul>
<h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><h4 id="px、em、rem、pt、vw、vh、"><a href="#px、em、rem、pt、vw、vh、" class="headerlink" title="px、em、rem、pt、vw、vh、"></a>px、em、rem、pt、vw、vh、</h4><h4 id="css优先级"><a href="#css优先级" class="headerlink" title="css优先级"></a>css优先级</h4><ul>
<li>!important &gt; 行内样式 &gt; ID选择器 &gt; class选择器 &gt; 标签选择器 &gt; *全局选择器 &gt; 继承 &gt; 浏览器默认样式</li>
<li>css解析原则：选择器是从右往左开始，优点：查询快，方便，层层查询父元素选择器就行  如果从左开始查询右边，每次都要递归所有组件选择器，时间复杂度、空间复杂度更大，</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mr.tom</p>
              <p class="site-description motion-element" itemprop="description">一个生活感悟和学习之路的旅程</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.tom</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
