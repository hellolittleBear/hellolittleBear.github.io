<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>CSS/HTML基础总结 | 徐曉熊</title>
  <meta name="author" content="隐隐约约">

  
  <meta name="description" content="愿效江水去不换~">
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="CSS/HTML基础总结">
  <meta property="og:site_name" content="徐曉熊">

  
  

  
    <meta property="og:image" content>
  

  
  <link href="/css/images/favicon.ico" rel="icon">
  

  <link rel="alternate" href="/atom.xml" title="徐曉熊" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>

</head>
</html>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">徐曉熊</a></h1>
  <h2><a href="/">勤而学，共勉之 ~</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="https://github.com/hellolittleBear">fork me on github</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-08-24T16:00:00.000Z"><a href="/2018/08/25/notes/">2018/08/25</a></time>
      
      
  
    <h1 class="title">CSS/HTML基础总结</h1>
  

    </header>
    <div class="entry">
      
        <p>css和html基础总结。汇集这些年遇到的问题。</p>
<a id="more"></a>
<h5 id="form表单的readonly和disabled属性"><a href="#form表单的readonly和disabled属性" class="headerlink" title="form表单的readonly和disabled属性"></a><font color="#67C23A">form表单的readonly和disabled属性</font></h5><ul>
<li><p>disabled指当 input 元素加载时禁用此元素。input内容不会随着表单提交。</p>
</li>
<li><p>readonly规定输入字段为只读。input内容会随着表单提交。</p>
</li>
<li><p>无论设置readonly还是disabled，通过js脚本都能更改input的value。</p>
</li>
</ul>
<hr>
<h5 id="CSS控制前端图片HTTP请求的各种情况示例"><a href="#CSS控制前端图片HTTP请求的各种情况示例" class="headerlink" title="CSS控制前端图片HTTP请求的各种情况示例"></a><font color="#67C23A">CSS控制前端图片HTTP请求的各种情况示例</font></h5><p><a href="https://www.jb51.net/css/469033.html" target="_blank" rel="noopener">链接</a></p>
<hr>
<h5 id="css权重问题"><a href="#css权重问题" class="headerlink" title="css权重问题"></a><font color="#67C23A">css权重问题</font></h5><p>id: 100<br>class: 10<br>tags: 1</p>
<h5 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a><font color="#67C23A">盒模型</font></h5><p>css中的盒子模型包括IE盒子模型和标准的W3C盒子模型。border-sizing: border-box, inherit, content-box</p>
<p>标准盒子模型： 指定的宽度就是内容区的宽度 width = contentWidth</p>
<p>IE盒子模型： 制定的宽度 = 绘制区域的宽度</p>
<p>inherit: 从父类继承box-sizing的值</p>
<hr>
<h5 id="前端一像素问题"><a href="#前端一像素问题" class="headerlink" title="前端一像素问题"></a><font color="#67C23A">前端一像素问题</font></h5><p>由于不同手机屏幕分辨率不同的问题，有些手机1px由2<em>2的像素点来渲染，有的屏幕使用3</em>3的像素点渲染，所以border:1px 会在移动端显示不同的大小。<br>解决方案：<br><strong><em> 1、transform: scale() 、 ::after </em></strong><br>transform: scaleY(0.5)使用伪元素设置1px的边框，然后对边框进行缩放(scaleY)，当然你还需要设置缩放基点，<strong><em>transform-origin: left top</em></strong>,</p>
<p><strong><em> 2、border-image </em></strong><br>border-image 设置图片的边框，这是比较老的方案，一般不会用了</p>
<hr>
<h5 id="CSS动画属性，transform、transition、animation"><a href="#CSS动画属性，transform、transition、animation" class="headerlink" title="CSS动画属性，transform、transition、animation"></a><font color="#67C23A">CSS动画属性，transform、transition、animation</font></h5><p>transform描述元素静态样式，而transition和animation描述元素动态样式。所以transform一般配合其他俩个一起使用达到动画效果。</p>
<p>不同点：</p>
<ul>
<li><p>触发条件不同。 transition通常与hover等事件触发。 而animation与GIF动态图类似，会立即触发动画效果。</p>
</li>
<li><p>循环性。 animation可以设置循环次数。</p>
</li>
<li><p>精确性。animation可以设置每一帧的样式，精确度比较高。而transition只能设置 form….to，头尾俩种状态。</p>
</li>
<li><p>js交互。animation立刻触发，很难与js交互。而transition是由事件触发的，交互非常紧密。</p>
</li>
</ul>
<hr>
<h5 id="居中问题"><a href="#居中问题" class="headerlink" title="居中问题"></a><font color="#67C23A">居中问题</font></h5><p><strong>固定宽高</strong></p>
<p><strong><em>元素垂直居中</em></strong></p>
<ul>
<li><p>使用 <strong><em>line-height: height</em></strong>,设置line-height和height相同高度，内容区的处于垂直居中，这样的话仅仅适合单行文本、图片上，多行文本视觉效果非常差。</p>
</li>
<li><p>使用 <strong><em> 绝对定位; top:50%; margin-top: - height / 2; </em></strong>，注意父元素需要相对定位，适用于多行元素垂直居中，而不是内容区垂直居中。</p>
</li>
<li><p>使用 <strong><em> 父元素display: table; 子元素display: table-cell; vertical-align:middle </em></strong> IE &lt; 8 不能用</p>
</li>
<li><p>js控制， <strong><em> 绝对定位; left: ($(window).width() - $(‘.div’).outerWidth())/2; top:($(window).height() - $(‘.div’).outerHeight())/2 </em></strong></p>
</li>
</ul>
<p><strong><em> 元素水平居中 </em></strong></p>
<ul>
<li><p>使用 <strong><em> margin: 0 auto </em></strong></p>
</li>
<li><p>使用 <strong><em> 绝对定位;left: 50%; margin-left: - width / 2 </em></strong></p>
</li>
<li><p>使用 <strong><em> text-align:center </em></strong> 文本水平居中</p>
</li>
</ul>
<p><strong>不固定宽高</strong></p>
<ul>
<li><p>使用 <strong><em>transform: translate(-50%, -50%)</em></strong> 如果是弹框的话,可以增加 <strong><em> position: flex; top 50%; left 50%; </em></strong></p>
</li>
<li><p>使用CSS3属性 <strong><em> display: flex; justify-content: center; align-items: center; </em></strong></p>
</li>
</ul>
<hr>
<h5 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a><font color="#67C23A">浮动</font></h5><p> <a href="https://juejin.im/post/5a954add6fb9a06348538c0d" target="_blank" rel="noopener">浮动解释</a></p>
<p><strong><em>清除浮动</em></strong></p>
<ul>
<li>给父级元素定义高度</li>
<li>让父级元素也浮动</li>
<li>父级定义display:table</li>
<li>父元素设置overflow:hidden</li>
<li>clearfix:使用内容生成的方式清除浮动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">coding...</span><br><span class="line">.clearfix:after &#123;  // :after选择器向选定的元素之后插入内容</span><br><span class="line">	content:&quot;&quot;; // 生成内容为空</span><br><span class="line">	display: block; // 块级元素显示</span><br><span class="line">	clear:both; // 清除前面元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="CSS选择器优先级问题"><a href="#CSS选择器优先级问题" class="headerlink" title="CSS选择器优先级问题"></a><font color="#67C23A">CSS选择器优先级问题</font></h5><p>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性<br>1.属性后面加!import 会覆盖页面内任何位置定义的元素样式<br>2.作为style属性写在元素内的样式<br>3.id选择器<br>4.类选择器<br>5.标签选择器<br>6.通配符选择器（*）<br>7.浏览器自定义或继承<br>同一级别：后写的会覆盖先写的</p>
<hr>
<h5 id="CSS绘画三角形"><a href="#CSS绘画三角形" class="headerlink" title="CSS绘画三角形"></a><font color="#67C23A">CSS绘画三角形</font></h5><ul>
<li>使用 <strong><em>border绘画</em></strong> 主要运用了border的四个边框呈现梯形的结构。 如果需要控制方向，使用 <strong><em>transform: rolate(45deg)</em></strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">width: 0;</span><br><span class="line">height: 0;</span><br><span class="line">border-left: 10px solid transparent;</span><br><span class="line">border-right: 10px solid transparent;</span><br><span class="line">border-bottom: 20px solid #ff0000;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图"></a><font color="#67C23A">雪碧图</font></h5><ul>
<li>解释： 多张图片或者图标组合一起形成一张图片。</li>
<li>优点： 减少HTTP请求次数。优化速率。</li>
<li>使用： background-position: (0px, 10px);截取图片</li>
</ul>
<hr>
<p>三、左边定宽，右边自适应<br>    方案一：左边设置浮动，右边宽度设置100%  .left{float:left}  .right:{width:100%}<br>    方案二：左设置浮动，右用cacl去补宽度计算 .left{float:left} .right:{width:cacl(100vw-200px}<br>    方案三：父容器设置display：flex  right部分是设置flex：1<br>    方案四：右边div套个包裹、并前置、左及包裹 双浮动</p>
<p>四、水平居中<br>    行内元素居中（父元素text-align:center）<br>    块状元素居中（块状元素没发用text-align）<br>        1.宽度一定：margin:auto<br>        2.宽度不定：块级变行内，然后在父上text-aligin<br>                float</p>
<p>四、BFC <a href="https://juejin.im/post/5909db2fda2f60005d2093db" target="_blank" rel="noopener">https://juejin.im/post/5909db2fda2f60005d2093db</a><br>    理解：BFC是css布局的一个概念，是一块独立的渲染区域，一个环境，里面的元素不会影响到外部的元素<br>    如何生成BFC：（脱离文档流）<br>             【1】根元素，即HTML元素（最大的一个BFC）<br>             【2】float的值不为none<br>             【3】position的值为absolute或fixed<br>             【4】overflow的值不为visible（默认值。内容不会被修剪，会呈现在元素框之外）<br>             【5】display的值为inline-block、table-cell、table-caption<br>    BFC布局规则：1.内部的Box会在垂直方向，一个接一个地放置。<br>             2.属于同一个BFC的两个相邻的Box的margin会发生重叠<br>             3.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此, 文字环绕效果，设置float<br>             4.BFC的区域不会与float box重叠。<br>             5.计算BFC的高度，浮动元素也参与计算<br>    BFC作用：1.自适应两栏布局<br>         2.可以阻止元素被浮动元素覆盖<br>         3.可以包含浮动元素—-清除内部浮动 原理:：触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内<br>         4.分属于不同的BFC时，可以阻止margin重叠</p>
<p>三、类的创建和继承<br>    （es5）new 一个function，在这个function的prototype里增加属性和方法, 类里面有方法和属性<br>     (es6)中class, extends<br>    继承：<br>         原型链继承： function Cat(){ } Cat.prototype = new Animal(); Cat.prototype.name = ‘cat’; 无法实现多继承<br>        构造继承：   使用父类的构造函数来增强子类实例。function Cat(name){Animal.call(this);this.name = name || ‘Tom’;} 无法继承父类原型链上的属性跟方法  installof去检验<br>        实例继承：  为父类实例添加新特性，作为子类实例的返回<br>        拷贝继承： 拷贝父类元素上的属性跟方法<br>        组合继承：构造继承 + 原型继承的组合体<br>        寄生组合继承：通过寄生方式，在构造继承上加一个Super函数(没有实例和方法) 让他的原型链指向父类的原型链<br>                  砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性<br>    如何判断是那种类型</p>
<p>四、异步回调（如何解决回调地狱）<br>    promise、generator、async/await</p>
<pre><code>promise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理
      2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱
      3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）
      4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败
        promise.all() 里面状态都改变，那就会输出，得到一个数组
        promise.race() 里面只有一个状态变为rejected或者fulfilled即输出
        promis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）
</code></pre><p>五、前端事件流<br>    事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。<br>      1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到<html>再到<body>就停止了。<br>          2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。<br>          3、冒泡阶段：事件又传播回文档<br>       阻止冒泡事件event.stopPropagation()<br>           function stopBubble(e) {<br>                if (e &amp;&amp; e.stopPropagation) { // 如果提供了事件对象event 这说明不是IE浏览器<br>                  e.stopPropagation()<br>                } else {<br>                  window.event.cancelBubble = true //IE方式阻止冒泡<br>                  }<br>                 }<br>       阻止默认行为event.preventDefault()<br>     function stopDefault(e) {<br>        if (e &amp;&amp; e.preventDefault) {<br>          e.preventDefault()<br>        } else {<br>          // IE浏览器阻止函数器默认动作的行为</body></html></p>
<pre><code>      window.event.returnValue = false
    }
  }
</code></pre><p>事件如何先捕获后冒泡？<br>  在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，<br>    对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p>
<p>哪些事件不支持冒泡事件：鼠标事件：mouserleave  mouseenter<br>            焦点事件：blur focus<br>            UI事件：scroll resize</p>
<p>六、事件委托（提高性能）<br>    简介：事件委托指的是，不在事件的（直接dom）上设置监听函数，而是在其父元素上设置监听函数。通过事件冒泡，父元素可以监听到子元素上事件的触发<br>          通过判断事件发生元素DOM的类型，来做出不同的响应。<br>    举例子： 最经典的就是ui和li标签的事件监听，比如我们在添加事件的时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加<br>    好处：可以比较合适动态元素的绑定，新添加的子元素也会监听函数，也可以有事件触发机制</p>
<p>七、js的new操作符做了什么？<br>    new操作符创建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象（return this）。<br>    如果不要父类的属性跟方法，在函数的prototype上去new这个父类。</p>
<p>八、改变函数内部this指针的指向函数(bind,apply,call)<br>    通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2…这种形式。</p>
<pre><code>bind 一个是返回一个函数，并不会立即执行 第二个是带参数（第一个参数要指向的this，后面的的参数用来传递
</code></pre><p>九、深拷贝和浅拷贝 <a href="https://juejin.im/post/5b00e85af265da0b7d0ba63f" target="_blank" rel="noopener">https://juejin.im/post/5b00e85af265da0b7d0ba63f</a> 从堆和栈都是内存中划分出来用来存储的区域开始讲起<br>    基本类型：undefined,null,Boolean,String,Number,Symbol 在内存中占据固定大小，保存在栈内存中<br>    引用类型：Object,Array,Date,Function,RegExp等    引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。<br>     基本类型的复制: 其实就是创建了一个新的副本给将这个值赋值给新变量， 改变值旧对象不会改变<br>     引用类型的复制： 其实就是复制了指针，这个最终都将指向同一个对象，改变其值新对象也会改变<br>    基本类型的比较 == 会进行类型转换</p>
<pre><code>浅拷贝：仅仅就是复制了引用，彼此操作不影响，slice() concat()  object.assign
深拷贝：在堆中重新分配内存，不同的地址，相同的值,互不影响的 JSON.parse()将一个js对象序列化为一个json字符串  JSON.stringify()将json字符串反序列化为一个js对象  es6的展开 {...}
深拷贝和浅拷贝的主要区别是：在内存中的存储类型不同
    浅拷贝：重新在堆栈中创建内存，拷贝前后对象的基本类型互不影响。只拷贝一层，不能对对象进行子对象进行拷贝
    深拷贝：对对象中的子对象进行递归拷贝，拷贝前后两个对象互不影响
</code></pre><p>十、跨域<br>    同源策略（协议+端口号+域名要相同）<br>    1、jsonp跨域(只能解决get）<br>        原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容<br>        步骤：1.去创建一个script标签<br>              2.script的src属性设置接口地址<br>              3.接口参数，必须要带一个自定义函数名，要不然后台无法返回数据<br>              4.通过定义函数名去接受返回的数据</p>
<pre><code>2、document.domain 基础域名相同 子域名不同
    3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name
    4、服务器设置对CORS的支持
    原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求
   5、利用h5新特性window.postMessage()

iframe元素创建包含另外一个文档的内联框架（行内框架）(setTimeout进行异步加载)
  解释：浏览器中的浏览器！用于设置文本或者图形的浮动图文框或容器
  它和跨域
    1、document.domain 实现主域名相同，子域名不同的网页通信
      都设置为超域：document.domain = &#39;demo.com&#39;
    2、window.postMessageht(data, url)，h5的API，启动跨域通信
</code></pre><p>十一、图片的懒加载和预加载<br>    预加载：提前加载图片，当用户需要查看是可以直接从本地缓存中渲染<br>      为什么要使用预加载：在网页加载之前，对一些主要内容进行加载，以提供用户更好的体验，减少等待时间。<br>                  否则，如果一个页面的内容过于庞大，会出现留白。<br>        解决页面留白的方案：1.预加载  2.使用svg站位图片，将一些结构快速搭建起来，等待请求的数据来了之后，替换当前的占位符<br>    实现预加载的方法：<br>             1.使用html标签<br>            2.使用Image对象<br>            3.使用XMLHTTPRequest对像，但会精细控制预加载过程</p>
<pre><code>懒加载（lazyload）：客户端优化，减少请求数和延迟请求数
    提升用户体验，
    减少无效资源的加载
    防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用
  原理：首先将页面上的图片的src属性设置为空字符串，而图片的真是路经则设置带data-original属性中，
    当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入到可视区域
    ，如果图片在可视区域将图片的src属性设置为data-original的值，这样就可以实现延迟加载。
</code></pre><p>十二、函数节流防抖<br>    什么是防抖：短时间内多次触发同一个事件，只执行最后一次，或者在开始时执行，中间不执行。比如公交车上车，要等待最后一个乘客上车<br>        什么是节流：节流是连续触发事件的过程中以一定时间间隔执行函数。节流会稀释你的执行频率，比如每间隔1秒钟，只会执行一次函数，无论这1秒钟内触发了多少次事件<br>    都为解决高频事件而来， scroll mousewhell mousemover touchmove onresize</p>
<p>十三、将arguments类数组转化为数组的方法<br>    Array.apply(null, arguments)<br>    Array.prototype.slice.apply(arguments)<br>    Array.from(arguments)</p>
<p>十四、高阶函数<br>    一、函数作为参数传递 抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中。这样一来可以分离业务代码中变化与不变的部分<br>        回调函数<br>    二、函数作为返回值传递</p>
<p>十五、如何判断一个变量是对象还是数组（prototype.toString.call()）。<br>    千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。<br>    typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。<br>        对于引用类型：除function，都返回object   null返回object。<br>    installOf() 用来判断A是否是B的实例，installof检查的是原型。<br>    toString() 是Object的原型方法，对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p>
<pre><code>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。

isProperty()方法测试一个对象是否存在另一个对象的原型链上。
</code></pre><p>十六、setTimeout 和 setInterval的机制<br>    因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的<br>    待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码</p>
<p>十七、var let const<br>    const：定义的变量不可修改，必须初始化 ，<br>    var：定义的变量可以修改，如果不初始化输出undefined，不会报错<br>    let：块级作用域，函数内部使用let定义后，会函数外部无影响<br>    let const 不会造成变量的提升</p>
<p>十八、js垃圾回收机制<br>    1.JS具有自动垃圾收集的机制<br>    2.JS的内存生命周期（变量的生命）<br>        1.分配你所需要的空间 var a = 20<br>        2.使用分配带的内存（读写） alert（a + 10）<br>        3.不适用的时候，释放内存空间 a = null<br>    3.JS的垃圾收集器每隔固定的时间就执行一次释放操作，通用的是通过标记清除的算法<br>    4.在局部作用域中，垃圾回收器很容易做出判断并回收，全局比较难，因此应避免全局变量</p>
<pre><code>   标记清除算法：js最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将他标记为&#39;进入环境&#39;，
         当变量离开（函数执行完后），就其标记为&#39;离开环境&#39;。垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，
         然后去掉环境中的变量以及被环境中该变量所引用的变量（闭包）。在这些完成之后仍存在标记的就是要删除的变量了
</code></pre><p>十九、渐进增强和优雅降级<br>    1.渐进增强就是针对低版本浏览器进行构建页面，保证最基本的功能，然后对高级浏览器进行效果、交互等改进和最佳功能达到更好的用户体验<br>    2.优雅降级：一开始构建完整的功能，然后对低版本的进行兼容</p>
<p>二十、undefined 和 null<br>    1.undefined类型只要一个，即undefined，当声明变量还未被初始化时就是undefined<br>    2.null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象<br>    3.NaN 与任何值都是相比较的结果都是false</p>
<p>二十一、valueof和tostring<br>    valueof：所有对象都有valueof，如果存在任意原始值，他就默认将对象转化为表示它的原始值。<br>                      如果对象是复合值，而却大部分对象无法真正表示一个原始值，因此默认的valueof()方法简单的返回对象本身，而不是返回原始值。<br>                      数组、函数和正则表达式简单的继承了这个more方法，返回对象本身</p>
<p>二十二、输入框的change和input事件<br>    onchange事件：要在input失去焦点的时候才触发<br>    oninput事件：要在用户输入的时触发，他是元素值发生变化时立即触发</p>
<p>二十三、同步和异步<br>    同步：由于js单线程，同步任务都在主线程上排队执行，前面任务没有执行完成，后面的任务会一直等待<br>    异步：不进入主线程，进入任务队列，等待主线程任务执行完成，开始执行。最基本的异步操作SetTimemot和SetInterval,等待主线程任务执行完，在开始执行里面的函数</p>
<p>二十四、函数的柯里化<br>     概念：一个函数接受函数A作为参数，运行后返回return function一个新的函数，并且可以处理A中的参数（只接受单一参数的函数）<br>     意义：将函数完全变成了接受一个参数，返回一个参数的固定形式，便于讨论和优化</p>
<p>二十五、while<br>    while循环会在指定条件为真时循环执行代码</p>
<p>二十六、TypeScript的优点：<br>      1、编译时的强类型，变成了强类型语言，还是编译成js 编译的时候就可以检验<br>      2、更好的模块化<br>      3、更好的是实现面向对象的编程，类、接口、模块</p>
<p>二十七、js的阻塞特性：所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。<br>              直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。<br>              为了提高用户体验，新一代浏览器都支持并行下载JS，但是JS下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。<br>    css阻塞：因为浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。<br>         而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。</p>
<p>二十八、meta元素可提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词</p>
<pre><code>                            node面试
</code></pre><p>一、koa中间件执行机制<br>    1.添加中间件的方式是使用Koa实例的use方法，并传入一个generator函数，这个generator函数接受一个next参数<br>    2.use的原理：function Application () {this.middleware = [] // 这个数组就是用来装一个个中间间的}<br>    3.每次执行use方法，就把外面传进来的generator函数push到middleware数组中<br>        app.use = function (fn) {this.middleware.push(fn)}<br>    4.koa中是预先通过use方法，将请求可能会经过的中间间装在一个数组中。<br>    5.callback函数就是请求到来的时候执行的回调。把装着中间件middleware的数组作为参数传递为compose这个方法。<br>    6.componse把毫无关系的一个个中间件给收尾串起来了，就好比我们平常的烤面筋<br>    7.componse将中间件从最后一个开始处理，并一直往前知道第一个中间件。其实最关键的就是将最后一个中间件得到generator<br>       作为参数传递给前一个中间件。当最后一个中间件的参数next是空的generator函数生成对象</p>
<pre><code>中间件是怎么跑起来的：https://juejin.im/post/591c8b4544d904006c90a2cb




                            vue面试
</code></pre><p>一、介绍下MVVM(数据的双向绑定）<br>    M: model数据模型<br>    V: view 界面<br>    MV:作为桥梁负责沟通view跟model<br>     只关心数据的流传，减少强耦合性。最关键的就是数据的双向绑定<br> 关键步骤：1.实现数据监听器Observer，用object.defineProperty()重写数据的get/set。值更新就在set中通知订阅者更新数据<br>      2.实现模板编译compile，深度遍历dom树，对每个元素节点的指令模板替换数据以及订阅数据<br>      3.实现watch用于连接Observer和compile，能够订阅并接受每一个属性的变动的通知，执行指令绑定的相应的回调函数，从而更新数据</p>
<p>mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，<br>加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到View 。</p>
<p>二、 eventBus vuex<br>     原理：eventbus 解决了兄弟组件之间事件传递问题,本质是订阅发布者模式，从而摆脱了兄弟之间需要父组件转而传递的复杂。还有一种方法是vuex数据流，单一状态树,rootState树根<br>              名词，专车。订阅者跟发布者都引用专车，这个vue实例，来完成订阅发布者。 emit（发布）  on(订阅一个组件)<br> npm包    vue-event-proxy</p>
<pre><code>vuex 是将数据单独的抽离出来，一种状态管理工具，它借鉴的是Flux、redux的基本思想，将转态抽离到全局形成一个store
</code></pre><p>三、watch:<br>    对属性进行监听，允许我们执行异步操作，限制我们执行该操作的频率（debounce），并在我们得到结果前，设置中间转态。</p>
<p>四、Vue的双向数据绑定实现原理<br>    1.核心就是数据劫持 + 发布/订阅者模式：vue使用的是Object.defineProperty()通过监听他的get/set事件，监听对数据的操作，从而触发数据同步</p>
<p> Object.defineProperty缺陷的：<br>    1.只能对属性进行数据劫持，并且需要深度遍历整个对象<br>    2.对于数组不能监听数据的变化<br>    而proxy原生支持监听数组的变化，并且可以直接对整个对象进行拦截，所有Vue在下个版本中用proxy替换object.defineProperty</p>
<p>五、nextTick原理</p>
<p>六、生命周期函数  <a href="https://juejin.im/post/5b41bdef6fb9a04fe63765f1" target="_blank" rel="noopener">https://juejin.im/post/5b41bdef6fb9a04fe63765f1</a><br>        new Vue（创建一个Vue对象）—&gt; beforeCreate —&gt; observer Data(开始监控data对象数据变化） —&gt; init event(vue内部初始化事件）</p>
<pre><code>     --&gt; created()  --&gt; compile(编译模板,把data里面的数据和模板生成html)  --&gt;  beforeMount(还没有生成HTML到元素上)  --&gt;

     mounted(挂载完成，也就是模板中的html渲染到了html页面中）  --&gt;  beforeUpdate (Vritual Dom)  --&gt; updated  --&gt; beforeDestroy --&gt; destroyed

1.ajax请求最好放在created里面，页面可以访问到this了
2.关于dom的操作要放在mounted里面，在mounted前面还没有生成dom
3.每次进入/离开组件都要做一些事情，用什么钩子函数：
    不缓存：进入的时候可以用created和mounted钩子，离开的时候可以使用beforedDestory（可以访问this）和destoryed


    缓存：缓存了组件之后，在次进入组件不会触发beforeCreate，created, beforeMount,mounted
          如果你想每次进入组件都做一些事情的话，你可以放在activated进入缓存组件的钩子中
</code></pre><p>七、keep-alive<br>    在被keep-alive包含的组件/路由，会多出两个生命周期：activated 和 deactivated<br>    actived在组件第一次渲染时会被调用，之后再每次缓存组件被激活时调用 调用机制：第一次进入缓存路由/组件，在mounted后面，beforeRouteEnter守卫传给 next 的回调函数之前调用：</p>
<p>八、Vue的SPA 如何优化加载速度<br>    1.减少入口文件体积<br>    2.静态资源本地缓存<br>    3.开启Gzip压缩<br>    4.使用SSR,nuxt.js</p>
<p>九、模块化<br>    基本概念： 1.在js中，一个模块就是实现特定功能的文件(js文件)<br>           2.遵循模块的机制，想要什么就加载什么模块<br>           3.模块化开发需要遵循规范</p>
<pre><code>js实现模块化规范
        1.AMD 浏览器  requirejs  模块被异步加载，模块加载不影响后面语句的运行 默认使用baseURL+ paths的路经解析方式
        2.CommonJS  nodejs
        3.ES6的import/export
        4.CMD 浏览器端

解决的问题：1.命名冲突 2.文件依赖 3.模块的复用 4.统一规范和开发方式
</code></pre><p>十、谈谈Vue和React组件化的思想<br>    1.我们在各个页面开发的时候，会产生很多重复的功能，比如element中的xxxx。像这种纯粹非页面的UI，便成为我们常用的UI组件，最初的前端组件也就仅仅指的是UI组件<br>    2.随着业务逻辑变得越来多是，我们就想要我们的组件可以处理很多事，这就是我们常说的组件化，这个组件就不是UI组件了，而是包具体业务的业务组件<br>    3.这种开发思想就是分而治之。最大程度的降低开发难度和维护成本的效果。并且可以多人协作，每个人写不同的组件，最后像撘积木一样的把它构成一个页面</p>
<p>十一、vue的依赖收集和watch原理</p>
<pre><code>                        React
</code></pre><p>一、react和vue的区别<br>       =&gt;  相同点：<br>        1.数据驱动页面，提供响应式的试图组件<br>        2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范<br>        3.数据流动单向，都支持服务器的渲染SSR<br>        4.都有支持native的方法，react有React native， vue有wexx<br>    =&gt;  不同点：<br>        1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的<br>        2.数据渲染：大规模的数据渲染，react更快<br>        3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目<br>        4.开发风格：react推荐做法jsx + inline style把html和css都写在js了<br>                vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件</p>
<p>二、redux中的reducer（纯函数）<br>    Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）更新state(这个state可以理解为上下累加器的结果）<br>    每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是’自身消减’(reduce),进而返回最新的state,这也就是典型reduce函数的用法：state -&gt;  action -&gt;  state</p>
<p>三、react的refs<br>    refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，<br>    它将接受地城dom元素或组件的已挂在实例，作为第一个参数</p>
<p>四、react中的keys<br>    帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它</p>
<p>五、React的生命周期<br>    三个状态：Mounting(已插入真实的DOM）<br>          Updating(正在被重新渲染)<br>          Unmounting(已移除真实的DOM)<br>    componentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，<br>    componentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用</p>
<p>六、React子组件向父组件传值<br>    父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。</p>
<p>七、React数据流</p>
<p>八、为什么虚拟DOM会提高性能 <a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/29504639?sort=created</a><br>    虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能<br>    具体实现步骤：<br>        ·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中<br>            ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异<br>        ·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。</p>
<p>九、diff算法<br>    1.把树形结构按照层级分解，只比较同级元素<br>    2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记<br>    3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面<br>    Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用<br>    react只会匹配相同的class的component（这里的class指的是组件的名字）<br>    合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制<br>    4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能</p>
<p>十、super</p>
<p>十一、简述下flux的思想<br>    flux的最大特点，就是数据的‘单向流动’<br>    1.用户访问View<br>    2.View发出用户的Action<br>    3.Dispatcher收到Action,要求state进行相应的更新<br>    4.store更新后，发出一个‘change’事件后，更新页面</p>
<p>十二、reac性能优化是哪个周期函<br>    shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，<br>    如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能</p>
<p>十三、react怎么划分业务组件和技术组件<br>    根据组件的职责通常把组件分为UI组件和容器组件<br>    UI组件负责UI的呈现，容器组件负责管理数据和逻辑<br>    两者通过React-redux提供connect方法联系起来</p>
<p>十四、setState<br>    setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列<br>    而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值<br>    那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误</p>
<pre><code>同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state

同步更新state:
    setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行
    也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步

例子：componentDidMount() {

    fetch(&#39;https://test.com&#39;)

    .then((res) =&gt; res.json())

    .then(
</code></pre><p>(data) =&gt; {<br>this.setState({ data:data });</p>
<pre><code>            StatusBar.setNetworkActivityIndicatorVisible(false);
        }


                    性能优化
</code></pre><p>一、webpack打包文件体积过大？（最终打包为一个js文件）<br>    1.异步加载模块<br>    2.提取第三库<br>    3.代码压缩<br>    4.去除不必要的插件</p>
<p>如何优化webpack构建的性能<br>    一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积<br>             2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理<br>             3.对一些组件库采用按需加载，避免无用的代码<br>    二、减少目录检索范围<br>             ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度</p>
<pre><code>三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias
</code></pre><p>二、我们把开发中的所有资源（图片，js、css文件）都看成模块，通过loader和plugins来对资源进行处理，打包成符合生产环节部署的前端资源。</p>
<p>三、移动端的性能优化<br>      1、首屏加载和按需加载，懒加载<br>      2、资源预加载<br>      3、图片压缩处理，使用base64内嵌图片<br>      4、合理缓存dom对象<br>      5、使用touchstart代替click（click 300毫秒的延迟）<br>      6、利用transform:translateZ(0)，开启硬件GUP加速<br>      7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明<br>      8、使用viewport固定屏幕渲染，加速页面渲染内容<br>      9、尽量使用事件代理，避免直接事件绑定</p>
<p>四、Vue的SPA 如何优化加载速度<br>    1.减少入口文件体积<br>    2.静态资源本地缓存<br>    3.开启Gzip压缩<br>    4.使用SSR,nuxt.js</p>
<p>五、移动端300ms延迟<br>    由来：300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。<br>         由于用户可以双击缩放或者是滚动的操作，当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作<br>        因次，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕<br>    解决方案：1.禁用缩放，设置meta标签 user-scalable=no<br>          2.fastclick.js<br>            原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即<br>                  发出click事件，并把浏览器在300ms之后真正的click事件阻止掉<br>    fastclick.js还可以解决穿透问题</p>
<p>六、页面的重构；在不改变外部行为的前提下，简化结构、添加可读性</p>
<pre><code>                        服务器端
</code></pre><p>一、状态码：</p>
<ul>
<li>2XX（成功处理了请求状态）<ul>
<li>200 服务器已经成功处理请求，并提供了请求的网页</li>
<li>201 用户新建或修改数据成功</li>
<li>202 一个请求已经进入后台</li>
<li>204 用户删除成功</li>
</ul>
</li>
<li>3XX（每次请求使用的重定向不要超过5次）<ul>
<li>304 网页上次请求没有更新，节省带宽和开销</li>
</ul>
</li>
<li>4XX（表示请求可能出错，妨碍了服务器的处理）<ul>
<li>400 服务器不理解请求的语法</li>
<li>401 用户没有权限（用户名，密码输入错误）</li>
<li>403 用户得到授权（401相反），但是访问被禁止</li>
<li>404 服务器找不到请求的网页，</li>
</ul>
</li>
<li>5XX（表示服务器在处理请求的时候发生内部错误）<ul>
<li>500 服务器遇到错误，无法完成请求</li>
<li>503 服务器目前无法使用（超载或停机维护）</li>
</ul>
</li>
</ul>
<p>二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销<br>    1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）<br>    2.304是    HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件<br>    3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tage客服端渲染该页面，并把Tage也存储在缓存中。客户端再次请求页面A<br>        并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回304</p>
<p>last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间<br>        客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，<br>        询问该事件之后文件是否被修改，没修改返回304<br>    有了Last-Modified，为什么还要用ETag？<br>        1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）<br>        2、某些服务器不能精确的得到文件的最后修改时间<br>        3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get<br>    ETag，为什么还要用Last-Modified？<br>        1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改<br>        2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。<br>    ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）<br>        1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。</p>
<p>三、get/post的区别<br>    1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&amp;相连； post方法是把提交的数据放在http包的Body中<br>    2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制<br>    3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值<br>    4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上</p>
<p>四、http协议的理解<br>    1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议<br>    2.基于TCP/IP通信协议来传递数据（HTML，图片资源）<br>    3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统<br>    4.http请求信息request：<br>        请求行（request line）、请求头部（header）,空行和请求数据四部分构成</p>
<pre><code>    请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
    请求头部，用来说明服务器要使用的附加信息
    空行，请求头部后面的空行是必须的
    请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
    状态行、消息报头、空行和响应正文

    状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
    消息报头，用来说明客户端要使用的一些附加信息
    空行，消息报头后面的空行是必须的
    响应正文，服务器返回给客户端的文本信息。
</code></pre><p>五、http和https<br>    https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密<br>    http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少</p>
<p>五、http1.0 1.1 2.0的区别<br>    长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接<br>    节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）<br>    host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域</p>
<pre><code>1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源
</code></pre><p>六、koa和express的区别<br>    1.异步流程的控制。express采用callback来处理异步，koa2采用的是async/await<br>    2.错误处理。express采用callback捕获异常，对深层次的异常捕获不了。koa采用try/catch</p>
<p>七、web缓存<br>    1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本<br>    2.缓存的好处<br>            （1）减少不必要的请求<br>        （2）降低服务器的压力，减少服务器的消耗<br>        （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）</p>
<p>八、常见的web安全及防护原理<br>    1.sql注入原理：通郭sql命令插入到web表单递交或者输入活命，达到欺骗服务器执行的恶意sql命令<br>            防范：1.对用户输入进行校验<br>                   2.不适用动态拼接sql<br>    2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。<br>                    举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息<br>                防范：1.尽量采用post而不使用get提交表单<br>                      2.避免cookie中泄漏用户的隐式<br>    3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求<br>                举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据<br>                防范：在客服端页面增加伪随机数，通过验证码<br>    XSS和CSRF的区别：<br>       1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包<br>       2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包</p>
<p>九、CDN（内容分发网络）<br>    1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。<br>    2.关键技术：内容存储和分发技术中<br>    3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术<br>            将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）</p>
<p>十、TCP三次握手    (客服端和服务器端都需要确认各自可收发）<br>    客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。<br>    第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段<br>    第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段<br>    第三次握手： 服务器端确认客服端收到了自己发送的报文段</p>
<p>十一、从输入url到获取页面的完整过程  <a href="https://blog.csdn.net/samjustin1/article/details/52650520" target="_blank" rel="noopener">https://blog.csdn.net/samjustin1/article/details/52650520</a><br>    1.查询NDS(域名解析),获取域名对应的IP地址<br>        查询浏览器缓存<br>    2.浏览器与服务器建立tcp链接（三次握手）<br>    3.浏览器向服务器发送http请求(请求和传输数据）<br>    4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器<br>    5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤<br>    6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来</p>
<p>十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print<br>    流程：解析html以及构建dom树 -&gt; 构建render树 -&gt;  布局render树 -&gt; 绘制render树<br>    概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树<br>          2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）<br>          3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置<br>          4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点</p>
<pre><code>重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上
    触发重绘的条件：改变元素外观属性。如：color，background-color等
    重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观
注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局

重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。
    每个页面都需要一次回流，就是页面第一次渲染的时候

重排一定会影响重绘，但是重绘不一定会影响重排
</code></pre><p>十三、为什么css放在顶部而js写在后面<br>    1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了<br>    2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。<br>    3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验</p>
<pre><code>但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面



                    设计模式
</code></pre><p>一、观察者模式：<a href="https://juejin.im/post/5a14e9edf265da4312808d86" target="_blank" rel="noopener">https://juejin.im/post/5a14e9edf265da4312808d86</a>   <a href="https://juejin.im/post/5af05d406fb9a07a9e4d2799" target="_blank" rel="noopener">https://juejin.im/post/5af05d406fb9a07a9e4d2799</a><br>    在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系<br>    简单理解：数据发生改变时，对应的处理函数就会自动执行。一个Subjet,用来维护Observers,为某些event来通知（notify）观察者</p>
<p>二、发布-订阅者  有一个信息中介，过滤 耦合性低<br>    它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。</p>
<p>两者的区别：<br>    1.观察者模式中，观察者知道Subject ,两者是相关联的，而发发布订阅者只有通过信息代理进行通信<br>    2.在发布订阅模式中，组件式松散耦合的。正好和观察者模式相反。<br>    3.观察者大部分是同步的，比如事件的触发。Subject就会调用观察者的方法。而发布订阅者大多数是异步的（）<br>    4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。</p>
<p>1004001111<br>                             数据结构和算法</p>
<p>一、两个栈实现一个队列，两个队列实现一个栈 <a href="https://www.cnblogs.com/MrListening/p/5697459.html" target="_blank" rel="noopener">https://www.cnblogs.com/MrListening/p/5697459.html</a></p>
<p>二、红黑树（解决二叉树依次插入多个节点时的线型排列） <a href="https://juejin.im/post/5a27c6946fb9a04509096248" target="_blank" rel="noopener">https://juejin.im/post/5a27c6946fb9a04509096248</a></p>
<p>三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）<a href="https://juejin.im/post/5a2ff8c651882533d0230a85" target="_blank" rel="noopener">https://juejin.im/post/5a2ff8c651882533d0230a85</a></p>
<p>四、十大排序<br>    1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。<br>      实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个<br>            2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数<br>            3.针对所有的元素重复以上的步骤，除了最后一个<br>            4.重复步骤1-3，直到排序完成。<br>    2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾<br>      实现过程：</p>
<pre><code>3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入
  实现过程：1.从第一个元素开始，该元素可以认为已经被排序
        2.取出下一个元素，在已排序的元素序列中冲后向前扫描
        3.如果该元素（以排序）大于新元素，将元素向后移一位

4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序

1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现
  实现过程：1.从数组中挑出一个元素，成为一个基准
        2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）
        这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。
        3.递归的把小于基准值的子数列和大于基准值元素的子数列排序
算法实现： function quickSort (arr) {
        if （arr.length &lt;= 1） {return arr}
        var destIndex = Math.floor(arr.length/2)
        var left = [], right = [];
        var dest = arr.splice(destIndex,1)[0];
        for (var i =0;i&lt;arr.length;i++){
            if (arr[i]&lt;dest) {
            left.push(arr[i])
            } else {
            right.push(arr[i]) }
        return quickSort(left).concat([dest],quickSort(right)


2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。
  实现过程：1.
</code></pre><p>五、数组去重 <a href="https://juejin.im/post/5aed6110518825671b026bed#heading-6" target="_blank" rel="noopener">https://juejin.im/post/5aed6110518825671b026bed#heading-6</a><br>    1.双重循环<br>    2.indexOf<br>    3.数组排序去重 最快你Olong</p>
<p>六、字符串<br>    判断回文字符串：（递归的思想）<br>        1.字符串分隔，倒转，聚合[…obj].reverse().join(‘’)<br>        2.字符串头部和尾部，逐次向中间检测<br>            实现：function isPalindrome(line) {<br>                line += ‘’;<br>                for (var i=0,j=line.length-1;i&lt;j;i++,j—) {<br>                    if (line.chartAt(i) !== line.chartAt(j) {<br>                    return false<br>                }</p>
<pre><code>    3.递归
</code></pre><p>七、二分查找（有序数组的查找）<br>     // 二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数<br>    //  (1) 一开始,数据范围覆盖整个数组。<br>    //  (2) 将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。<br>    //  (3) 就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T<br>    代码实现：function binarySearch (data, dest, start, end){<br>            var end = end || data.length-1;<br>            var start = start || 0;<br>            var m = Math.floor((start+end)/2);<br>            if (dest&lt;data[m]){<br>                return binarySearch(data, dest,0, m-1)<br>            } else {<br>                return binarySearch(data, dest, m+1, end)<br>            }}<br>            return false</p>
<pre><code>                        手写代码
</code></pre><p>一、动手实现一个bind（原理通过apply，call）<br>    一句话概括：1.bind()返回一个新函数，并不会立即执行。<br>            2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数<br>            3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效<br>Function.prototype.bind = function (obj, arg) {<br>   var arg = Array.prototype.slice.call(arguments, 1);<br>   var context = this;<br>   var bound = function (newArg) {<br>   arg = arg.concat(Array.prototype.slice.call(newArg);<br>   return context.apply(obj, arg)<br>}<br>  var F =  function () {}  // 在new一个bind会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程<br>  F.prototype = context.prototype;00…………………..<br>  bound.prototype =  new F();<br>  return bound;<br>}</p>
<p>二、 AJAX （异步的javascript和xml）<br>    ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。<br>    优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载<br>          可以把前端服务器的任务转嫁到客服端来处理，减轻服务器负担，节省宽带<br>    劣势：不支持back。对搜索引擎的支持比较弱；不容易调试<br>    怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，<br>    解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax<br>function getData(url) {<br>    var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象<br>    xhr.open(‘get’, url, true)  // 设置一个http请求，设置请求的方式，url以及验证身份<br>    xhr.send() //发送一个http请求<br>    xhr.onreadystatechange = function () {  //设置一个http请求状态的函数<br>      if (xhr.readyState == 4 &amp;&amp; xhr.status ==200) {<br>        console.log(xhr.responseText)  // 获取异步调用返回的数据<br>      }<br>    }<br>  }<br>  Promise(getData(url)).resolve(data =&gt; data)</p>
<pre><code> AJAX状态码：0 - （未初始化）还没有调用send()方法
         1 - （载入）已调用send方法，正在发送请求
         2 - （载入完成呢）send()方法执行完成
         3 - （交互）正在解析相应内容
         4 - （完成）响应内容解析完成，可以在客户端调用了
</code></pre><p>三、函数节流（throttle）<br> function throttle (func, wait) {<br>        var timeout;<br>        var previous = 0;<br>        return function () {<br>            context = this;<br>            args = arguments;<br>            if (!timeout) {<br>                timeout = setTimeout(() =&gt; {<br>                    timeout = null;<br>                    func.apply(context,args)<br>                }, wait);<br>            }<br>        }<br>    }</p>
<p>}</p>
<p>四、函数防抖（dobounce）<br> function debounce (func, wait) {<br>         var timeout;<br>         return function() {<br>             var context = this;<br>             var args = arguments;<br>             clearTimeout(timeout);<br>             timeout = setTimeout(() =&gt; {<br>                 func.apply(context,args)<br>             }, wait);<br>         }<br>     }</p>
<p>五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</p>
<pre><code>Object.prototype.clone = function() {
  var newObject = this.constructor === Array ? [] : {}  //对象的深拷贝 获取对应的构造函数 [] 或者 {}
  for (let e in this) { //遍历对象的属性 in  this[e]
    newObject[e] = typeof this[e] === &#39;object&#39; ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型
  }
  return newObject
}
</code></pre><p>六、实现一个简单的Promise <a href="https://juejin.im/post/5b2f02cd5188252b937548ab" target="_blank" rel="noopener">https://juejin.im/post/5b2f02cd5188252b937548ab</a><br>class Promise {<br>  constructor (executor) {   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。<br>    this.status = ‘pending’,<br>    this.value = undefined;<br>    this.reason = undefined;<br>    // 成功存放的数组<br>    this.onResolvedCallbacks = [];<br>     // 失败存放法数组<br>     this.onRejectedCallbacks = [];<br>    let resolve = (value) =&gt; {<br>      if (this.status == ‘pending’) {<br>        this.status = ‘resolve’;<br>        this.value = value;<br>        this.onResolvedCallbacks.forEach(fn =&gt; fn())<br>      }<br>    }</p>
<pre><code>let reject = (reason) =&gt; {
  if (this.status == &#39;pending&#39;) {
    this.status = &#39;reject&#39;;
    this.reason = reason;
    this.onRejectedCallbacks.forEach(fn =&gt; fn())
  }
}
try{
  executor(resolve, reject);
} catch (err) {
  reject(err);
}
</code></pre><p>  }<br>  then (onFullFilled,onRejected) {<br>    if (this.status == ‘resolved’) {<br>      onFullFilled(this.value)<br>    }<br>    if (this.status == ‘rejectd’) {<br>      onRejected(this.reason);<br>    }<br>    if (this.status == ‘pending’) {<br>      this.onResolvedCallbacks.push(()=&gt;{<br>        onFullFilled(this.value);<br>      })<br>      this.onRejectedCallbacks.push(()=&gt; {<br>          onRejected(this.reason);<br>      })<br>  }</p>
<p>  }<br>}</p>
<p>const p = new Promise((resolve, reject) =&gt; {<br>  setTimeout(() =&gt; {<br>      resolve(‘hello world’)<br>  }, 1000);<br>})<br>p.then((data) =&gt;{<br>  console.log(data)<br>},(err) =&gt;{<br>  console.log(err);<br>})</p>
<p>七、发布订阅者模式（观察者模式）</p>
<p>var event = {}; // 发布者<br>event.clientList = [] //发布者的缓存列表</p>
<p>event.listen = function (fn) {  // 增加订阅者函数<br>  this.clientList.push(fn)<br>}</p>
<p>event.trigger = function () {  // 发布信息<br>  for (var i =0;i&lt;this.clientList.length;i++) {<br>    var fn = this.clientList[i];<br>    fn.apply(this, arguments);<br>  }<br>}</p>
<p>event.listen (function(time) {<br>  console.log(‘正式上班时间为：’ +time)<br>})<br>event.trigger (‘2018/7’)</p>
<p>八、手动写一个node服务器<br>const http = require(‘http’);<br>const fs = require(‘fs’);<br>const server = http.createServer((req,res) =&gt; {<br>    if (reu.url == ‘/‘) {<br>    const indexFile = fs.createReadStream(‘./index.html’)<br>    req.writeHead(200,{‘context-Type’:’text/html;charset = utf8})<br>    indexFile.pipe(res)<br>}<br>server.listen(8080)</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/前端/">前端</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/兴趣/">兴趣</a><small>3</small></li>
  
    <li><a href="/categories/前端/">前端</a><small>9</small></li>
  
    <li><a href="/categories/前端基础/">前端基础</a><small>1</small></li>
  
    <li><a href="/categories/后端/">后端</a><small>1</small></li>
  
    <li><a href="/categories/工具/">工具</a><small>2</small></li>
  
    <li><a href="/categories/算法/">算法</a><small>1</small></li>
  
    <li><a href="/categories/项目/">项目</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2019/08/05/jiangxi/">江西发展为什么这么落后于周边省份？？</a>
      </li>
    
      <li>
        <a href="/2019/08/01/carreer-plan/">IT行业个人感悟</a>
      </li>
    
      <li>
        <a href="/2019/07/15/webpack-source/">webpack理解</a>
      </li>
    
      <li>
        <a href="/2019/06/24/mathjax/">mathjax编辑语法</a>
      </li>
    
      <li>
        <a href="/2019/05/15/probability/">抛硬币概率期望使之最高效讨论</a>
      </li>
    
  </ul>
</div>


  

  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2019  <a href="https://github.com/hellolittleBear" target="_blank">hellolitterBear</a></p>
  
  All rights reserved. Powered by <a href="https://hellolittlebear.github.io" target="_blank">blog</a><p></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="bg"></div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>